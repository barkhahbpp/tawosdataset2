Name,Title,Description,Type,Priority,Status,Creation_Date,Estimation_Date,Story_Point
"Hyperledger Fabric","Expose an Admin endpoint for the channel participation API","The channel participation API endpoint should adopts the style of the   [Operations API](([https://hyperledger-fabric.readthedocs.io/en/release-2.0/operations_service.html#operations-security]))   in the orderer.         We intend to provide an additional HTTP server that is hosted only the orderer, and expose the endpoint   `/participation/v1`, which has a single resource `/channels`. the orderer configuration, as    expressed in the `orderer.yaml` file, will identify endpoint configuration parameters that are unique to the channel    participation API. The _local orderer channel participation admin_ is not identified by the MSP, but rather through mutual TLS.   Like in the operations API that handles log-spec,         1. Add to the config of `ChannelParticipation:` in `orderer.yaml` the following parameters:      {code:yaml}    # host and port for the operations server     ListenAddress: 127.0.0.1:8443      # TLS configuration for the operations endpoint     TLS:    # TLS enabled       Enabled: false      # Certificate is the location of the PEM encoded TLS certificate       Certificate:     # PrivateKey points to the location of the PEM-encoded key       PrivateKey:     # ClientAuthRequired requires client certificate authentication    # at the TLS layer to access all resources.       ClientAuthRequired: false      # Paths to PEM encoded ca certificates to trust for client authentication       ClientRootCAs: []  {code}  2. Define a separate (new) HTTP server in `server/main.go` and register the channel participation HTTP handler to it, rather than to the operations API.",Story,High,"In CR Review","2020-09-25 06:29:17","2020-09-25 06:29:17",2
"Hyperledger Fabric","Back-porting Go Modules to 1.x","Is there any chance that the migration to go modules could be back-ported for the latest 1.x release (1.4.8 at the time of this writing)?    I want to write a chain code with the latest 1.x version, but really dislike the legacy package management of go and the need to manage $GOPATH and other env vars (personal preference).    If I understand it correctly all it would take is a single commit that adds a go.mod file on the 1.x branch and then a release of a minor version that gets tagged so go can pick it up as a version. Also happy to send a PR with this if people support the idea. Please advise.",Story,Medium,Closed,"2020-08-25 17:22:11","2020-08-25 17:22:11",3
"Hyperledger Fabric","PTEv2 README","Add PTEv2 README",Task,Medium,"In CR Review","2020-08-11 19:39:54","2020-08-11 19:39:54",1
"Hyperledger Fabric","Remove ledger resources in an asynch way","In this task FAB-17964 the ledger resources are removed in a synchronous way. This may create problems when the channel's ledger is big. Here we improve upon that by removing the ledger in an asynch fashion. (see review comments [here|https://github.com/hyperledger/fabric/pull/1637#discussion_r462343435]  and [here|https://github.com/hyperledger/fabric/pull/1637#discussion_r465503129] ).         The `r.ledgerFactory.Remove(channelID)` operation may take a long time. This operation is performed under the global registrar lock. If this takes even more then a fraction of a second, it will impact the performance of the server on all other channels. This method    // GetChain retrieves the chain support for a chain if it exists.    func (r *Registrar) GetChain(chainID string) *ChainSupport     \{    r.lock.RLock()    defer r.lock.RUnlock()    return r.chains[chainID]    \}    is called by every client request, through BroadcastChannelSupport  so we can't really hold that lock for too long (for write - exclusive).    What is propose is asynch deletion:   * introduce a {{*toBeRemoved* set (e.g. map[string]bool }}) that holds channels that are being removed.   * After stopping the channel move the *{{channelID}}* to that set,   * and only then delete the ledger, but make the delete async with a different go-routine.   * release the lock.   * when the delete go-routine finishes, it removes the *{{channelID}}* from the *{{toBeRemoved}}*   * any attempt to `Join` or `Remove` should also check the *{{toBeRemoved}}*",Story,Medium,"In Progress","2020-08-10 15:26:34","2020-08-10 15:26:34",3
"Hyperledger Fabric","operator supports PTEv2","PTEv2 (FAB-17973) supports invoke and query using high level SDK and will be available soon.  Operator will need to use PTEv2 rather PTE for invoke and query.",Task,Medium,"In Progress","2020-08-06 16:09:13","2020-08-06 16:09:13",1
"Hyperledger Fabric","PTEv2 supports transientMap","PTEv2 supports transientMap.  The format of transientMap will be similar to the one listed below:    {        marble: {            name:marble,            color:blue,            size:35,            owner:tom,            price:99        }    }    PTEv2 will need to re-assign certain keys in the Map in order to have unique asset for each transaction.     ",Task,Medium,"In CR Review","2020-07-30 20:17:50","2020-07-30 20:17:50",1
"Hyperledger Fabric","Validate TLS intermediate certs against the TLS root certs","Created based on [this discussion in github|https://github.com/hyperledger/fabric-config/pull/35#discussion_r460927399].    The validateCACerts code [here|https://github.com/hyperledger/fabric-config/blob/a97807f0619130c8aa7fe1ce33b19109168ca55a/configtx/msp.go#L893-L905] should be refactored/reused to validate that the signature for each of the TLS intermediate CA certs has a valid signature from one of the TLS root CA certs.    Note: if you really feel like getting extra credit, you can see if we can incorporate the TODO to use cert.Verify() to provide a more complete verification but simply using tlsIntermediateCert.CheckSignatureFrom(tlsRootCert) is sufficient for now. ",Story,Medium,Backlog,"2020-07-28 21:40:56","2020-07-28 21:40:56",1
"Hyperledger Fabric","Add example for individual Orderer value updates","Add an example to show migrating to etcdraft using the individual orderer update functions.     ",Story,Medium,Closed,"2020-07-24 15:18:10","2020-07-24 15:18:10",1
"Hyperledger Fabric","PTEv2 supports grpc timeout and request timeout","PTEv2 sets grpc timeout and request timeout when connecting to gateway.",Task,Medium,"In CR Review","2020-07-24 13:45:46","2020-07-24 13:45:46",1
"Hyperledger Fabric","PTEv2 supports peer failover","PTEv2 supports peer failover",Task,Medium,"In CR Review","2020-07-23 16:00:05","2020-07-23 16:00:05",1
"Hyperledger Fabric","PTEv2 support invoke check","PTEv2 supports invoke check    After invokes execution, PTEv2 can perform queries for invoke validation.  User can specify the number of query, such as all invoke transactions or last n transactions and the peers that the queries to be sent.",Task,Medium,"In CR Review","2020-07-21 20:26:28","2020-07-21 20:26:28",1
"Hyperledger Fabric","PTEv2 supports general chaincode args","In order to have a unique key for each transaction, PTEv2 supports general chaincode args ",Task,Medium,"In CR Review","2020-07-21 15:32:46","2020-07-21 15:32:46",1
"Hyperledger Fabric","PTEv2 supports user specified target peers","PTEv2 sets target peers if not service discovery based on user specification.    The supported target peers are:     ORGANCHOR: the anchor peer (the first peer listed in the org)    ALLANCHORS: all anchor peers of all orgs    ORGPEERS: all peers in the same org    ALLPEERS: all peers listed in the connection profile    LIST: specific peers in the list    DISCOVERY: service discovery, no target peer is set",Task,Medium,"In CR Review","2020-07-21 15:24:54","2020-07-21 15:24:54",1
"Hyperledger Fabric","Make RemoveChannel crash fault tolerant","We need to make the {{Remove}} operation crash fault tolerant. The {{blkstorageProvider.Drop(channelID)}} may take a while, removing the index and then the folder, and if in that time there is a crash there is no recovery from {{blkstorageProvider}}. We need to mark the channel for removal with the file-repo at the start of this method, and unmark at the end. If we restart and find a channel marked for removal, we deed to retry the {{Drop()}}.",Story,Medium,"In CR Review","2020-07-21 15:17:40","2020-07-21 15:17:40",2
"Hyperledger Fabric","PTEv2 supports constant mode transaction","PTEv2 supports constant mode transaction with user specified frequency and deviation frequency",Task,Medium,"In CR Review","2020-07-21 15:14:07","2020-07-21 15:14:07",1
"Hyperledger Fabric","PTEv2 supports filtered block event","PTEv2 supports filtered block event",Task,Medium,"In CR Review","2020-07-21 15:12:45","2020-07-21 15:12:45",2
"Hyperledger Fabric","PTEv2 supports service discovery","PTEv2 supports service discovery with collection",Task,Medium,"In CR Review","2020-07-21 15:11:38","2020-07-21 15:11:38",1
"Hyperledger Fabric","PTEv2 supports invoke and query","PTEv2 executes invokes and queries using high level SDK-node",Task,Medium,"In CR Review","2020-07-21 15:09:36","2020-07-21 15:09:36",2
"Hyperledger Fabric","Support individual MSP value updates","As a consumer of the fabric-config library, I would like to update individual fields in and organizations MSP configuration without having to go through the existing process of cloning the MSP configuration via `GetMSP()` and then modifying the specific fields I want to update. Currently if you wanted to add a single admin cert  to  an orderer org's MSP config, you would do something like:    While the existing `GetMSP` -> `SetMSP` model has it's own use cases, the above could have simply been supported as     which is both more in line with how the rest of the API operates and less confusing for having to follow a different process than for say `ordererOrg.AddOrdererEndpoint`.         For now, lets keep the existence of `SetMSP` and `GetMSP` and just add the other functions to support a separate path for making individual field updates.         *Acceptance*    There are new api functions for `OrdererOrgGroup`, `ApplicationOrgGroup`, and `ConsortiumOrgGroup` that implement each of the supported values we add via `SetMSP`: [https://github.com/hyperledger/fabric-config/blob/7beda2c830d8d474eda0b187ef9cd8ecb3195724/configtx/orderer.go#L471]   * Perform any certificate validation if necessary   * AddRootCert/RemoveRootCert   * AddIntermediateCert/RemoveIntermediateCert   * AddAdminCert/RemoveAdminCert   * AddCRL/RemoveCRL (using or replacing the already supported CreateMSPCRL, this function never actually modified the ConfigGroup type it was associated with and was instead used in conjunction with the SetMSP flow)   * AddOUIdentifier/RemoveOUIdentifier   * SetCryptoConfig   * AddTLSRootCert/RemoveTLSRootCert   * AddTLSIntermediateCert/RemoveTLSIntermediateCert   * SetClientOUIdentifier/SetPeerOUIdentifier/SetAdminOUIdentifier/SetOrdererOUIdentifier   * EnableNodeOUs/DisableNodeOUs    The examples are also updated to either show both methods of updating an MSP.     ",Story,Medium,Closed,"2020-07-10 22:28:11","2020-07-10 22:28:11",1
"Hyperledger Fabric","Implement a config transaction bulk operation CLI tool","As a user with a network of many channels, I would like to perform bulk operations on a subset of channels with a CLI tool that consumes the fabric-config library.         Some initial bulk operations we'd like supported include:    *Cert Expiry*   Update channel MSP that only requires one signature   TLS certs for orderers in consenter set    *V1 to V2 migration*   Remove dead consenter from channel   Remove dead anchor peers   Add anchor peers         Requirements:  * Option to run the tool in dry-run mode - show the calculated update  * error message when doing any operation other than the supported ones  * stack multiple operations     Use cases:  REPLACE: Update channel MSP - admins  DELETE: Remove dead consenter from channel  UPDATE: TLS certs for orderers in consenter set  ADD: Anchor Peer  DELETE: Anchor Peer     Connection Profile: Use Fabric connection profile format  [https://hyperledger-fabric.readthedocs.io/en/release-2.0/developapps/connectionprofile.html]      Support a --dryrun flag that prints the update to stdout and can be redirected to a file       The tool will take a JSON input indicating the update that also specifies a connection profile for connecting to a peer to use the discovery service for fetching config blocks. The tool should both support fetching the config block via the information provided in the connection profile as well as submitting the config update transaction         *Acceptance*    I can use the cli tool to update a network with many channels by performing the same config update operations on a selected list of channels for the network. I can pass signing identities and a connection profile for connecting to a peer for fetching config blocks and submitting transactions to the orderer. An example command should look something like:  ",Story,Medium,Closed,"2020-07-06 14:50:35","2020-07-06 14:50:35",5
"Hyperledger Fabric","Implement function for adding/removing consenters from an etcdraft orderer configuration","As a consumer of the fabric config API, I would like to call a function for quickly adding or removing consenters from the consenter set of an etcdraft orderer configuration. Currently this is already achievable via fetching the entire orderer configuration and setting a new orderer configuration with the consenters updated, but the addition of these API functions will reduce the need for overriding the entire orderer configuration. Note: removal should match all 4 fields (host port and both certs) to be safe.    *Acceptance*    I can call functions to add and remove consenters from an etcdraft orderer configuration similar to how I can do so for orderer endpoints of an orderer org and anchor peers of application orgs.",Story,Medium,Closed,"2020-07-06 14:43:00","2020-07-06 14:43:00",1
"Hyperledger Fabric","Implement function that removes KafkaBrokers value","As a consumer of the fabric config API I would like to call a function during my migration from Kafka to EtcdRaft to remove the KafkaBrokers section from my config.    The KafkaBrokers section should normally not be used if the consenter type is etcdraft but this function enables us to support cleaning up migrated configs.    *Acceptance*    I can call a function to entirely remove KafkaBrokers similar to the API function for removing top level orderer addresses. As example is also added/improved for demonstrating how to migrate from Kafka to EtcdRaft.",Story,Medium,Closed,"2020-07-06 14:39:32","2020-07-06 14:39:32",1
"Hyperledger Fabric","Use a Dedicated Kubernetes Cluster for Barebone Regression Tests","To achieve more consistent results on the barebones test scenarios, the tests should be migrated from docker, to kubernetes running on dedicated VM's.    Set KUBE_CONFIG to execute on Kubernetes    go run main.go -k $KUBE_CONFIG    Use ibmcloud CLI to login to the cluster and get the kubeconfig    The client will also need to be on a dedicated VM. They exist in the `Fabric System Test` pool.    We need to clean up the directory at the end of the test.    Acceptance criteria: Performance tests are executed on kubernetes.",Task,Medium,Backlog,"2020-06-10 04:09:45","2020-06-10 04:09:45",1
"Hyperledger Fabric","Update Test Scenarios to Use v2.0 Application Capabilities","Until recently we did not have the tooling in place to launch networks using the 2.0 capabilities due to a lack of support in the SDK's for the 2.0 lifecycle.    Now that the tooling exists we should upgrade all test scenarios to use the 2.0 application capabilities.    Acceptance criteria: All tests use 2.0 application capabilities.",Task,Medium,"In CR Review","2020-06-10 04:03:23","2020-06-10 04:03:23",1
"Hyperledger Fabric","Stop Testing Branches Other Than Master","Now that our LTS strategy states we will not backport breaking changes to prior releases, we will stop performing automated daily tests on branches prior to our current master.    We should disable the daily/weekly test suites for these branches by removing the CRON entry in the pipeline definition files. This does not include nightly publishing jobs.    I'll note that a user can simply navigate to Azure DevOp's to trigger the tests should the need arise.    This will allow us to focus efforts towards ongoing and future work, rather than monitoring old releases and backporting changes.    Acceptance criteria: No nightly tests execute on branches outside of master.",Task,Medium,Backlog,"2020-06-10 03:34:24","2020-06-10 03:34:24",1
"Hyperledger Fabric","Modify and Extend Upgrade Scenario","Today we execute the upgrade test by going from 1.4 -> 2.0 -> 2.1    We need to update the test to perform two scenarios:   * 1.4 -> 2.0 -> 2.1 -> 2.2   * 1.4 -> 2.2    Of note is that the 1.4 -> 2.2 upgrade will no longer require the user to drop the database when using couchdb. If the upgrade scenario doesn't use couchDB, it should be modified to us couch.    This test should be modified to run daily and only executed on the master branch.    Acceptance criteria: A daily job runs two upgrades scenarios, one to across all releases since the last LTS release, and one that runs from the last LTS directly to the newest LTS.",Task,High,"In CR Review","2020-06-10 03:28:58","2020-06-10 03:28:58",2
"Hyperledger Fabric","Remove the system channel from a network with channels","Allow a network running with a system channel to migrate and start operate with out it. The flow for doing so is:   * Enable the channel participation API on all OSNs (a staggered restart of all OSNs is required).   * Put the system channel into maintenance mode in order to prevent channel creation when it is removed, resulting in inconsistencies across orderers.   * Remove the system channel with the channel participation API.   * Prevent config transactions that change orderer channel membership on app channels, to avoid triggering a transition from Inactive <-> Raft    ** A simple option is to Halt all the channels, and   ** Halt the InactiveChainRegistry   * Removal should remove also all the channels the orderer is not a member of   * Restart every chain (or restart the server), in order to recreat the chains and convert every chain and its haltCalback pointers from Raft+Inactive to Raft+Follower   * Normal activity may resume",Story,Medium,Closed,"2020-06-08 14:00:49","2020-06-08 14:00:49",3
"Hyperledger Fabric","Support backwards compatibility in configtx by introducing API function for removing top level orderer endpoints","As a consumer of the fabric-config API attempting to migrate a fabric 1.0 channel, I would like to use the configtx library to remove the top level orderer addresses in my 1.0 channel config in favor of later adding them to the orderer org instead. We should not allow people to update the OrdererAddresses field and instead only support a function for removing it. New genesis blocks should also be created without the top level field but instead require the orderer orgs to specify orderer endpoints (tl;dr required at org level when creating, optional when updating)         *Acceptance*    I should be able to call a function `RemoveLegacyOrdererAddresses` from the top level of a new ConfigTx's channel group to remove the legacy config value.",Story,Medium,Closed,"2020-06-02 15:40:33","2020-06-02 15:40:33",1
"Hyperledger Fabric","Support returning an unsigned config update envelope","As a consumer of the fabric config api I would like to have the flexibility of not having to require having signing identities at time of generating the config update so that I can take the config update transaction and sign it via the peer channel commands instead.         *Acceptance*    I can call a function that returns a cb.ConfigUpdateEnvelope without requiring any signing identities.",Story,Medium,Closed,"2020-05-11 15:02:21","2020-05-11 15:02:21",1
"Hyperledger Fabric","Implement function that adds a consortium","As a consumer of the fabric config API I would like to call a function to add a new consortium to the consortiums group. Consider any implications that may arise should the user not add any orgs to the new consortium (if that even matters) as well as for any examples (we should add orgs to the consortium after adding a new consortium in any examples).         *Acceptance*    I can call a function to add a new consortium group. Examples are also updated demonstrating addition of a new consortium + orgs for that consortium.",Story,Medium,Closed,"2020-04-27 14:32:29","2020-04-27 14:32:29",1
"Hyperledger Fabric","Demo CLI for configtx package","As a member of the hyperledger community, I would like to see a demo/sample configtx CLI that utilizes the configtx package so that I have a better idea of how to consume the library. This CLI may end up being a community tool as well that replaces configtxgen for general config transaction generation.         *Acceptance*    **A simple CLI exists for the configtx library that has commands and flags for generating system channel genesis blocks, application create channel transactions, and config updates supporting all updatable config properties via flags or subcommands.    Example:    The above command (or something similar to it) should produce a config update transaction adding anchor peer newhost:123 to Org1.    The CLI should be well documented for use cases in the help/manual.",Story,Medium,Closed,"2020-04-22 23:21:37","2020-04-22 23:21:37",3
"Hyperledger Fabric","Improve GoDoc for config library","As a consumer of the fabric config API GoDocs, I would like to see better documentation around configtx.New(). There are also a couple of unnecessary examples that add nothing to the GoDoc and can be removed, namely    * [ConfigTx.AddApplicationCapability|https://godoc.org/github.com/hyperledger/fabric/pkg/config#example-ConfigTx-AddApplicationCapability]   * [ConfigTx.AddChannelCapability|https://godoc.org/github.com/hyperledger/fabric/pkg/config#example-ConfigTx-AddChannelCapability]   * [ConfigTx.AddOrdererCapability|https://godoc.org/github.com/hyperledger/fabric/pkg/config#example-ConfigTx-AddOrdererCapability]   * [ConfigTx.RemoveApplicationCapability|https://godoc.org/github.com/hyperledger/fabric/pkg/config#example-ConfigTx-RemoveApplicationCapability]   * [ConfigTx.RemoveChannelCapability|https://godoc.org/github.com/hyperledger/fabric/pkg/config#example-ConfigTx-RemoveChannelCapability]   * [ConfigTx.RemoveOrdererCapability|https://godoc.org/github.com/hyperledger/fabric/pkg/config#example-ConfigTx-RemoveOrdererCapability]   * [ConfigTx.UpdateApplicationMSP|https://godoc.org/github.com/hyperledger/fabric/pkg/config#example-ConfigTx-UpdateApplicationMSP]   * [New|https://godoc.org/github.com/hyperledger/fabric/pkg/config#example-New]    since these examples just demonstrate how to call the function.    As part of this story, let's also rename the Example_xxx functions to be more appropriate for what they are examples for (ie. Example_systemChannel should just be Example_textExample since it's the overall flow for how to compute and sign a config update. You may need to clarify the proper GoDoc metadata for this). Let's also split up the Example_XXX examples into more distinct examples (ie Example_ACLs which demonstrate quick usage for adding/removing ACLs).         While we're at it lets also remove the Output validation from the examples since they don't add much.    One final nit: try to keep the code blocks in the generated GoDocs from needing to scroll horizontally by introducing linebreaks where appropriate.         GoDocs can be generated locally by running    in the terminal then navigating to localhost in the browser{{}}    *Acceptance*   * Unnecessary examples removed   * Better documentation around New   * Example_XXX functions renamed   * Additional smaller Example_XXX functions for different values (ie. Example_policyRetrieval, Example_ordererUpdate, Example_membership, etc)   * Output validation removed from examples   * No horizontal scroll on any code blocks in the GoDocs",Story,Medium,Closed,"2020-04-13 21:04:54","2020-04-13 21:04:54",2
"Hyperledger Fabric","Removal functions should be idempotent","As a consumer of the fabric config API, I would like to remove values from a config and expect no error to occur if the value attempting to be removed does not exist. If a value being removed doesn't already exist then it should be expected that the resulting updated config doesn't contain the value being removed inherently so there is no need to error in these cases. Consider removing the returned error entirely if it makes sense.         *Acceptance*    Calling a removal function with a value that does not exist does not return any error. The GoDoc should clearly explain this behavior.",Story,Medium,Closed,"2020-04-13 20:55:45","2020-04-13 20:55:45",1
"Hyperledger Fabric","Move MSP related types to a membership subpackage","As a consumer of the fabric API, I would like to reference msp related types in a separate namespace from configtx. Currently a consumer would pass a configtx.MSP type which has configtx.CryptoConfig, configtx.NodeOUs, etc properties. The subproperty types should be moved to a separate membership package within the configtx library such that they can be referenced as membership.CryptoConfig, membership.NodeOUs, etc. Note this story is only for namespacing the types, no functions should be moved unless deemed necessary/more appropriate to live in the membership subpackage.         *Acceptance*    I can find a new membership folder/package within the configtx package that contains the msp related types for SigningIdentityInfo, OUIdentifier, CryptoConfig, NodeOUs,. The new Orderer package should be well documented/have a well formed GoDoc.",Story,Medium,Closed,"2020-04-13 20:47:19","2020-04-13 20:47:19",1
"Hyperledger Fabric","Move Orderer related types to an orderer subpackage","As a consumer of the fabric API, I would like to reference orderer related types in a separate namespace from configtx. Currently a consumer would pass a configtx.Orderer type which has configtx.BatchSize, configtx.Kafka, etc properties. The subproperty types should be moved to a separate orderer package within the configtx library such that they can be referenced as orderer.Kafka, orderer.BatchSize, etc. Consider if it would look better to also create new types for orderer.Policies of type map[string]Policy (this may not be cleanly possible since we use shared functions for all types of policies). Note this story is only for namespacing the types, no functions should be moved unless deemed necessary/more appropriate to live in the orderer subpackage.         *Acceptance*    I can find a new orderer folder/package within the configtx package that contains the orderer related types for Kafka, EtcdRaft, BatchSize, ConsensusState. The new Orderer package should be well documented/have a well formed GoDoc.",Story,Medium,Closed,"2020-04-13 20:46:44","2020-04-13 20:46:44",1
"Hyperledger Fabric","Chain config type APIs","As a consumer of the fabric config API, I would like to chain the API calls when attempting to update or retrieve values in the config. Currently the ConfigTx type supports all of the add/remove/set/update functions for all values on the config. Let's consider extending sub types with their associated getters and setters so we change from calling:    c.AddAnchorPeers(...) -> c.Application().Org(orgName).AddAnchorPeer()    Use careful consideration when determining how to and which types to wrap for the intermediary subtypes. In the example above, should ConfigTx contain references to a configtx.Application type which wraps a ConfigGroup proto?         *Acceptance*    I can chain API calls for getting/setting values on a config. The examples and GoDoc should be updated accordingly.",Story,Medium,Closed,"2020-04-13 20:39:47","2020-04-13 20:39:47",3
"Hyperledger Fabric","Rename ConfigTx.Base() and ConfigTx.Updated()","As a consumer of the fabric config API, I'd like to call more appropriate functions on a ConfigTx type that return the base and updated config. Currently the function Base() isn't very clear as to what it should accomplish. We should consider renaming this to something more appropriate (eg. BaseConfig, OriginalConfig, OldConfig, etc...) and likewise rename Updated() to something similar (ie UpdatedConfig).         *Acceptance*    The Base() and Updated() functions and associated GoDocs are updated to reflect the new names.",Story,Medium,Closed,"2020-04-13 20:32:17","2020-04-13 20:32:17",1
"Hyperledger Fabric","Convert AddXXX and UpdateXXX functions to SetXXX","As a consumer of the fabric config API, I would like to call Set functions for setting values on the updated config. Currently the Add functions check that the existing config does not already have the value being added. Let's convert this behavior to just override whatever config value the consumer is intending to set. Let's also rename the UpdateXXX functions to use the Set prefix for consistency purposes.         *Acceptance*    All AddXXX and UpdateXXX functions in the configtx package have been updated to SetXXX and support replacing the value being added. These functions should not error if the value being set already exists and should instead replace them. Use careful discretion when applying this behavior to slices (ie. SetAnchorPeer) as the struct is not a map. The goal is a duplicate is not added in these cases where an existing AnchorPeer may already exist in the slice. The examples should be updated where applicable to use the new SetXXX functions. The GoDoc should also be updated to properly reflect existing values will be overwritten where applicable.",Story,Medium,Closed,"2020-04-13 20:27:26","2020-04-13 20:27:26",2
"Hyperledger Fabric","Extend SigningIdentity with config update signing functions","As a consumer of the fabric config API, I would like to use a signing identity to create config update signatures. Currently when opening the GoDoc the first function we see is CreateSignedConfigUpdateEnvelope, which is quite a wordy first impression. Let's consider renaming this to just SignConfigUpdateEnvelope (not to be confused with the existing SignConfigUpdate) and extend the SigningIdentity to potentially encapsulate both SignConfigUpdate and SignConfigUpdateEnvelope. The GoDoc documentation should explain the usage and differences between the two.          *Acceptance*    SigningIdentity should be extended with SignConfigUpdate at the minimum. Consider also extending with  the renamed SignConfigUpdateEnvelope if deemed necessary.",Story,Medium,Closed,"2020-04-13 20:13:45","2020-04-13 20:13:45",1
"Hyperledger Fabric","Add configtx package documentation","As a consumer of the fabric config API, I would like to see an Overview section in the GoDocs that explains the purpose and usage of the configtx package. Maybe also mention how channels are structured.         *Acceptance*    I can open the GoDocs and find an Overview section for the configtx package that clearly explains what the library is for.",Story,Medium,Closed,"2020-04-13 20:08:32","2020-04-13 20:08:32",1
"Hyperledger Fabric","Validate consenter certs when adding to application channel (and system channel)","When adding a consenter node to the application channel, it is required that they have the relevant MSP that's contributing the node into the Orderer section... Otherwise any invokes on the channel fails since the channel is in a bad state... if they are going from one to two consenter, the channel is in a irrecoverable state.     We should check and see if the necessary certs are in MSP before allowing a consenter addition",Story,Medium,Closed,"2020-04-09 22:40:24","2020-04-09 22:40:24",2
"Hyperledger Fabric","Implement function for creating system channel genesis block","As a consumer of the fabric config API, I would like to be able to create genesis blocks for system channels. As a reminder, system channel genesis block does not create an application group and instead only fills the channel config group with an orderer and consortiums group. Whether we choose to combine this function with application channel creation like what was done in the original configtx encoder, or we choose to split them into separate API functions is up to the implementer.         *Acceptance*    I can call a function to create a system channel genesis block. There should be a new example added that demonstrates this behavior.",Story,Medium,Closed,"2020-04-03 18:22:08","2020-04-03 18:22:08",2
"Hyperledger Fabric","Implement function for removing a consortium","As a consumer of the fabric config API I'd like to be able to remove a consortium from a config transaction.         *Acceptance*    I can call a function for removing a specific consortium from a channel config. The examples should be updated as well to demonstrate usage.",Story,Medium,Closed,"2020-03-27 16:14:28","2020-03-27 16:14:28",1
"Hyperledger Fabric","Implement functions for removing orgs","As a consumer of the fabric config API I'd like to be able to remove consortium, application, and orderer orgs from a config transaction.         *Acceptance*    I can call separate functions for removing an organization from a consortium, application, and orderer. The examples should be updated as well to demonstrate usage.",Story,Medium,Closed,"2020-03-27 16:13:28","2020-03-27 16:13:28",1
"Hyperledger Fabric","Remove Get Prefix on Accessors for ConfigTx functions","[https://golang.org/doc/effective_go.html#Getters]         func (c *ConfigTx) GetAnchorPeers(...) -> func (c *ConfigTx) AnchorPeers(...)         [https://github.com/hyperledger/fabric/pull/880#discussion_r397418783]",Story,Medium,Closed,"2020-03-26 13:58:14","2020-03-26 13:58:14",1
"Hyperledger Fabric","Move config package out from Fabric","We want to remove the config package from Fabric before the release-2.1 branch is cut so it doesn't go into v2.1.0. This may involve a formal RFC justifying the creation (can probably just refer to information in FAB-17628) so the linux foundation can approve and create a new repo for us.         *Acceptance*    A new repo created in the hyperledger org that contains renamed packages for the config code. Contributing guide, CI process/configuration, integration tests exist for the new repo.",Story,Highest,Closed,"2020-03-18 19:00:30","2020-03-18 19:00:30",3
"Hyperledger Fabric","Implement functions for adding and removing ACLs from an application group","As a user of the Fabric channel configuration API, I would like to be able to update an application groups's ACLS by adding or removing ACLs.         *Acceptance*    I should be able to call this function to modify a config transaction and then process further configuration updates on the modified config transaction. The examples test should be updated to demonstrate usage of this feature.     ",Story,Medium,Closed,"2020-03-18 16:20:08","2020-03-18 16:20:08",1
"Hyperledger Fabric","Implement helper function for retrieving application configuration from an existing config","As a user of the Fabric channel configuration API, I would like to be able to retrieve existing application configuration without manually parsing the config transaction.         *Acceptance*    I should be able to call a function for retrieving application configuration that returns a config.Application.",Story,Medium,Closed,"2020-03-18 16:16:19","2020-03-18 16:16:19",1
"Hyperledger Fabric","Implement functions for adding and removing capabilities from a config","As a user of the Fabric channel configuration API, I would like to be able to add and remove application, orderer, and channel capabilities. Consider whether we should allow setting unsupported capabilities outside of the existing ones or if we should just have toggles (ie EnableV20ApplicationCapabilities() and Disable...)         *Acceptance*    I should be able to call these functions to modify a config transaction and then process further configuration updates on the modified config transaction. The examples test should be updated to demonstrate usage of this feature.     ",Story,Medium,Closed,"2020-03-18 16:14:57","2020-03-18 16:14:57",1
"Hyperledger Fabric","Wrap config transaction proto and move API to wrapped type","Currently we pass a config object around to every update/API function, lets wrap the config proto so this:    becomes something like     ",Story,Medium,Closed,"2020-03-13 14:29:09","2020-03-13 14:29:09",2
"Hyperledger Fabric","Implement helper function for retrieving policies for a specific org from an existing config","As a user of the Fabric channel configuration API, I would like to be able to retrieve existing policies for an organization without manually parsing the config transaction.         *Acceptance*    I should be able to call a function for retrieving policies for a specific org (regardless of application/orderer/consortium org). The example test should also be updated to demonstrate usage of this helper.",Story,Medium,Closed,"2020-03-09 20:22:15","2020-03-09 20:22:15",1
"Hyperledger Fabric","Implement function that removes an orderer endpoint","As a fabric administrator, I want to use a fit-for-purpose library that can modify an existing channel configuration to remove an orderer endpoint from an orderer org's config group.    Acceptance:   Starting with an existing Config block/transaction, I can call a function that removes an orderer endpoint from the configuration. After performing that operation, I can compute a ConfigUpdate transaction that is ready for a signature workflow. An appropriate example should also be added to the example test that demonstrates this behavior.",Story,Medium,Closed,"2020-03-06 19:44:50","2020-03-06 19:44:50",1
"Hyperledger Fabric","Implement function that adds an orderer endpoint","As a fabric administrator, I want to use a fit-for-purpose library that can modify an existing channel configuration to add an orderer endpoint to an orderer org's config group.    Acceptance:   Starting with an existing Config block/transaction, I can call a function that adds an orderer endpoint to the configuration. After performing that operation, I can compute a ConfigUpdate transaction that is ready for a signature workflow. An appropriate example should also be added to the example test that demonstrates this behavior.",Story,Medium,Closed,"2020-03-06 19:42:28","2020-03-06 19:42:28",1
"Hyperledger Fabric","Verify that a cert is issued by an MSP before adding to revocation list","As a fabric administrator, I want to verify that a cert was issued by my organization's MSP before adding it to the MSP's revocation list.    Acceptance:   Provided with a config block/transaction, I can call a function to revoke a certificate issued by an MSP. This should result in a configuration update that appropriately modifies the {{revocation_list}} attribute of {{FabricMSPConfig}}.    Providing a certificate that has not been issued by the MSP should result in an error.",Story,Medium,Closed,"2020-03-05 15:39:22","2020-03-05 15:39:22",2
"Hyperledger Fabric","Rename pkg/config to something more appropriate","config as a package name isn't very descriptive of what this package is. We should consider renaming the package to something more appropriate for what it actually does (maybe configtx?)",Story,Medium,Closed,"2020-03-02 21:07:55","2020-03-02 21:07:55",1
"Hyperledger Fabric","Implement helper function for retrieving msp configuration for a specific org from an existing config","As a user of the Fabric channel configuration API, I would like to be able to retrieve existing msp configuration for an organization without manually parsing the config transaction so I can reuse CA certs or other relevant information.         *Acceptance*    I should be able to call a function for retrieving msp configuration for a specific org. The example test should also be updated to demonstrate usage of this helper.",Story,Medium,Closed,"2020-03-02 20:07:37","2020-03-02 20:07:37",1
"Hyperledger Fabric","Implement function to add an application org to a channel config","As a fabric administrator, I want to use a fit-for-purpose function that adds an application org definition to a channel configuration. The result of this function should be a channel transaction that can be passed to other functions that can further mutate the config.    *Acceptance*    Calling the new function with appropriate arguments should generate a config transaction that contains a new application org. The examples test should also be updated to demonstrate usage of this feature.",Story,Medium,Closed,"2020-03-02 19:09:58","2020-03-02 19:09:58",1
"Hyperledger Fabric","Implement function to add an orderer org to a channel config","As a fabric administrator, I want to use a fit-for-purpose function that adds an orderer org definition to a channel configuration. The result of this function should be a channel transaction that can be passed to other functions that can further mutate the config.    *Acceptance*    Calling the new function with appropriate arguments should generate a config transaction that contains a new orderer org. The examples test should also be updated to demonstrate usage of this feature.",Story,Medium,Closed,"2020-03-02 19:06:02","2020-03-02 19:06:02",1
"Hyperledger Fabric","Implement function for adding and removing policies for consortium orgs and consortiums/consortium groups","As a user of the Fabric channel configuration API, I would like to be able to update a consortium org's, consortiums group's, and consortium group's configuration by adding or removing policies.         *Acceptance*    I should be able to call this function to modify a config transaction and then process further configuration updates on the modified config transaction. The examples test should be updated to demonstrate usage of this feature.     ",Story,Medium,Closed,"2020-03-02 18:55:33","2020-03-02 18:55:33",1
"Hyperledger Fabric","Implement functions for adding and removing policies for orderer orgs and orderer group","As a user of the Fabric channel configuration API, I would like to be able to update an orderer org's and orderer group's configuration by adding or removing policies.         *Acceptance*    I should be able to call this function to modify a config transaction and then process further configuration updates on the modified config transaction. The examples test should be updated to demonstrate usage of this feature.     ",Story,Medium,Closed,"2020-03-02 18:54:08","2020-03-02 18:54:08",1
"Hyperledger Fabric","Implement functions for adding and removing policies for application orgs and application groups","As a user of the Fabric channel configuration API, I would like to be able to update an application org's and an application group's configuration by adding or removing policies.         *Acceptance*    I should be able to call this function to modify a config transaction and then process further configuration updates on the modified config transaction. The examples test should be updated to demonstrate usage of this feature.     ",Story,Medium,Closed,"2020-03-02 18:48:10","2020-03-02 18:48:10",1
"Hyperledger Fabric","Implement helper function for retrieving an org's configuration from an existing config","As a user of the Fabric channel configuration API, I would like to be able to retrieve existing application, orderer, or consortium org configuration without manually parsing the config transaction so I can persist values I don't want to change when updating an org's configuration.         *Acceptance*    I should be able to call a function for retrieving an application, orderer, or consortium org's configuration that returns a config.Organization. I can then modify fields on the Organization and pass it to an appropriate update organization function to update the org's configuration. The example tests should also be updated to demonstrate usage of this helper.",Story,Medium,Closed,"2020-03-02 18:44:20","2020-03-02 18:44:20",1
"Hyperledger Fabric","Implement helper function for retrieving orderer configuration from an existing config","As a user of the Fabric channel configuration API, I would like to be able to retrieve existing orderer configuration without manually parsing the config transaction so I can persist values I don't want to change when updating orderer configuration         *Acceptance*    I should be able to call a function for retrieving orderer configuration that returns a config.Orderer. I can then modify fields on the Orderer configuration and pass it to config.UpdateOrdererConfiguration to update the orderer's configuration. The example tests should also be updated to demonstrate usage of this helper.",Story,Medium,Closed,"2020-03-02 18:38:07","2020-03-02 18:38:07",1
"Hyperledger Fabric","Implement helper function for retrieving anchor peers from an existing config","As a user of the Fabric channel configuration API, I would like to be able to retrieve existing anchor peers without manually parsing the config transaction.         *Acceptance*    I should be able to call a function for retrieving anchor peers for a specific org. The example test should also be updated to demonstrate usage of this helper.",Story,Medium,Closed,"2020-03-02 18:34:55","2020-03-02 18:34:55",1
"Hyperledger Fabric","Implement an Example test that demonstrates creating a new create channel tx","As a user of the Fabric channel configuration API, I would like an example in the library documentation that shows me idiomatic usage of the package to create new channel create transactions and sign them.         *Acceptance*    I can find an example for creating create channel transactions in the GoDoc for the package.",Story,Medium,Closed,"2020-03-02 18:22:50","2020-03-02 18:22:50",2
"Hyperledger Fabric","Implement an Example test that demonstrates idiomatic usage of the library","As a user of the Fabric channel configuration API, I would like an example in the library documentation that shows me idiomatic usage of the package to create configuration updates and sign them. The updates should involve multiple changes to instruct on how state is managed.         *Acceptance*    I can find an example for updating channel transactions in the GoDoc for the package. It should also sign the config update envelope.",Story,Medium,Closed,"2020-02-27 14:40:55","2020-02-27 14:40:55",2
"Hyperledger Fabric","Implement function to add a root CA to an MSP","As an administrator, I want to use a fit for purpose library to add a new root CA certificate to an MSP configuration.    Acceptance:  Starting with a configuration transaction/block, I can call a function that adds CA certificate to the MSP configuration. After this operation, I should be able to create a config update transaction that is ready for the signature workflow.    Minimal certificate validation should be done when processing the function. In particular, reject certificates that is missing the KeyUsageCertSign/CA attributes.",Story,Medium,Closed,"2020-02-26 13:30:32","2020-02-26 13:30:32",2
"Hyperledger Fabric","Implement function to revoke a certificate issued by an MSP","As a fabric administrator, I want to use a fit for purpose library to generate a configuration update that revokes a certificate issued by my organization's MSP.    Acceptance:   Provided with a config block/transaction, I can call a function to revoke a certificate issued by an MSP. This should result in a configuration update that appropriately modifies the {{revocation_list}} attribute of {{FabricMSPConfig}}.",Story,Medium,Closed,"2020-02-26 13:25:00","2020-02-26 13:25:00",3
"Hyperledger Fabric","Implement function that removes an anchor peer","As a fabric administrator, I want to use a fit-for-purpose library that can modify an existing channel configuration to remove an anchor peer.    Acceptance:  Starting with an existing Config block/transaction, I can call a function that removes an anchor peer from the configuration. After performing that operation, I can compute a ConfigUpdate transaction that is ready for a signature workflow.    https://hyperledger-fabric.readthedocs.io/en/release-1.4/channel_update_tutorial.html#updating-the-channel-config-to-include-an-org3-anchor-peer-optional",Story,Medium,Closed,"2020-02-26 13:15:15","2020-02-26 13:15:15",1
"Hyperledger Fabric","Implement function that adds an anchor peer","As a fabric administrator, I want to use a fit-for-purpose library that can modify an existing channel configuration to add an anchor peer.    Acceptance:  Starting with an existing Config block/transaction, I can call a function that adds an anchor peer to the configuration. After performing that operation, I can compute a ConfigUpdate transaction that is ready for a signature workflow.    https://hyperledger-fabric.readthedocs.io/en/release-1.4/channel_update_tutorial.html#updating-the-channel-config-to-include-an-org3-anchor-peer-optional",Story,Medium,Closed,"2020-02-26 13:14:09","2020-02-26 13:14:09",2
"Hyperledger Fabric","Implement function to add an org to an existing consortium","As a fabric administrator, I want to use a fit-for-purpose function that adds an org definition to a named consortium in system channel configuration. This result of this function should be a channel update transaction that can later be signed.     Acceptance    Calling the new function with appropriate arguments should generate a config update transaction that semantically matches one produced by the process that uses {{configtxgen}} {{-printOrg}}, {{protolator}}, and {{configtxgen}}.    This story is only concerned with adding the org to the consortium - not creating a channel.    Most of the manual steps are documented here: https://hyperledger-fabric.readthedocs.io/en/release-2.0/channel_update_tutorial.html",Story,Medium,Closed,"2020-02-17 14:15:37","2020-02-17 14:15:37",2
"Hyperledger Fabric","Implement function to compute a ConfigUpdate from a base and modified configuration transaction","As a fabric administrator, I want to use a fit-for-purpose library function to calculate a ConfigUpdate message that would update a {{base}} config to the {{modified}} config. This function should not need to be provided with anything beyond the two transactions.    Acceptance    Calling the new function with appropriate arguments should generate a {{ConfigUpdate}} that is semantically equivalent to the output of {{configtxlator compute_update}}.    See https://hyperledger-fabric.readthedocs.io/en/release-1.4/channel_update_tutorial.html for the current manual process.",Story,Medium,Closed,"2020-02-10 14:23:05","2020-02-10 14:23:05",3
"Hyperledger Fabric","Implement function to generate ConfigGroup for a new Organization","As a fabric administrator, I want to use a fit-for-purpose library function to generate a ConfigGroup representing an Organization. The input to the function should not depend on existing MSP material but should accept directly the necessary cryptographic material.    Acceptance    Calling the new function with appropriate arguments should generate a proto structure that is semantically equivalent to one generated by {{cryptogen}} and {{configtxgen -printOrg}}.",Story,Medium,Closed,"2020-02-10 14:12:36","2020-02-10 14:12:36",2
"Hyperledger Fabric","Implement orderer configuration transaction that can update batch parameters","As a fabric administrator, I want to use a fit-for-purpose library to generate a channel update transaction that modifies the {{max_message_count}} batch size parameter. The channel update transaction that is generated should not be signed.    Acceptance    Calling the new function with appropriate arguments should generate a config update transaction that matches one produced by manually transforming and generating a configuration update using the existing tools (ignoring any signature that may be applied by the existing tools).",Story,Medium,Closed,"2020-02-03 18:24:21","2020-02-03 18:24:21",2
"Hyperledger Fabric","Implement function to attach signatures to a configuration update transaction","As a fabric admin, I want to take a {{ConfigUpdate}} transaction and a collection of detached signatures and use them to create a complete, signed channel config update transaction that can be validated by the orderer and the peers.    Acceptance:    The generated configuration transaction should be equivalent to one generated by building up signatures in order using the existing `signtx` command on the peer.",Story,Medium,Closed,"2020-02-03 18:22:44","2020-02-03 18:22:44",2
"Hyperledger Fabric","Implement function to create a detached signature for a ChannelUpdate","As a fabric admin, I wish to sign a {{ChannelUpdate}} transaction and generate a detached signature. The key material used to sign the transaction should be one of the input parameters and should not be derived from configuration.    Acceptance:    Calling the new function with appropriate arguments generates a detached signature that I can use later as one of the _n_ required signatures when assembling the configuration update transaction.",Story,Medium,Closed,"2020-02-03 18:20:03","2020-02-03 18:20:03",2
"Hyperledger Fabric","Implement function to generate create channel transaction from parameters","As a fabric administrator, I want to use a fit-for-purpose library to generate a channel creation transaction from input data structures. This library should not make assumptions about how any key material is stored and should not require network access.    Acceptance:    Calling a function similar to what we have below returns a proto-encoded genesis block that roughly matches that produced by {{configtxgen -channelID channel-id -profile profile-name ...}} using a prototypical {{configtx.yaml}} from our integration test suite.    Generating a genesis block from the configtx.yaml and an msp folder, and using code implemented in this story, I should get two `proto.Equal` blocks.        The types that are listed above come from the {{genesisconfig}} package in fabric and appear to be managed through a combination of viper and yaml processing. We do not want to use these packages directly; we want to copy and adapt the necessary structures into our package.",Story,Medium,Closed,"2020-02-03 18:04:12","2020-02-03 18:04:12",5
"Hyperledger Fabric","Enable service discovery to query the _lifecycle endorsers on a channel","Similar to using service discovery to determine the endorsers needed to meet a user-defined chaincode's endorsement policy, we should also be able to use it to discover the endorsers required to commit a chaincode definition using _lifecycle.    Acceptance:  - Query _lifecycle on a specific channel and receive the valid list of endorsers required to meet the endorsement policy. (Version does not come into play.)    The list of endorsement should match the active configuration. This will likely involve creating a test with a non-standard _lifecycle endorsement policy.",Story,Medium,Closed,"2020-01-07 19:37:48","2020-01-07 19:37:48",3
"Hyperledger Fabric","Add a basic test that confirms expected proto types get decorated.","Per https://gerrit.hyperledger.org/r/c/fabric/+/34401#message-eccb8901_793a8c92    The protolator decoration stuff https://github.com/hyperledger/fabric/blob/33139a966bb75377f65c5d9dc990619bd80ca22d/common/tools/protolator/protoext/decorate.go is currently missing any sort of tests.    Some changes would be caught by integration tests, but a more  basic level of unit testing, ensuring that we are not accidentally omiting decoration of a type we intend to decorate would be nice.",Story,Medium,Closed,"2019-11-15 17:58:57","2019-11-15 17:58:57",3
"Hyperledger Fabric","RuntimeLauncher needs to be extended to support Stopping or disconnecting from chaincode","Chaincode execution is currently managed through RuntimeLauncher. The launcher needs to be extended to include a Stop verb to properly disconnect from / shutdown running chaincode that is launched through the external/container/platform packages.",Story,Medium,Closed,"2019-11-11 16:36:54","2019-11-11 16:36:54",3
"Hyperledger Fabric","When chaincode defined with the new lifecycle are no longer defined in any channel, they should be stopped","There is a state listener in the new lifecycle that tracks when chaincode is invocable (or not). Today, when a chaincode becomes invocable, we call the custodian to start it... A similar call needs to be made when a chaincode is no longer invocable to request the custodian to stop it.    The lifecycle cache already has a reference counted list of channel references to chaincode.    Acceptance:  1. Install chaincode with a name and package-ID A  2. Define chaincode  3. Install chaincode with name and package-ID B  4. Upgrade chaincode definition to B  5. Observe that chaincode container for package-ID A is stopped.    This story applies to internal platform chaincode and externally built and launched chaincode.",Story,Medium,Closed,"2019-11-11 16:32:54","2019-11-11 16:32:54",2
"Hyperledger Fabric","New lifecycle should cleanup from failed build during install","When using the new lifecycle to install chaincode, if the build fails due to timeout or some other reason such that the endorsement fails at the peer, the chaincode package should be removed from the local file system.    This prevents an odd behavior where the invoke of a chaincode that failed to build (during install) succeeds.",Story,Medium,Closed,"2019-11-04 16:43:51","2019-11-04 16:43:51",2
"Hyperledger Fabric","Remove ledger 'type' from orderer config","The orderer used to have the ramledger, the jsonledger, and the fileledger.  Both of the former types have been removed, so requiring a type to be specified is confusing and unnecessary.",Story,Medium,Closed,"2019-10-21 16:33:52","2019-10-21 16:33:52",1
"Hyperledger Fabric","As a Fabric operator, I don't want my chaincode installs to timeout when they would otherwise be successful.","We have seen in many of our tests, that shifting the build from the first invoke to install, that many existing automated scripts now fail with a timeout.  It would be nice if we could automatically increase the timeout for chaincode install operations.",Story,Medium,Closed,"2019-10-18 19:04:14","2019-10-18 19:04:14",3
"Hyperledger Fabric","Create a 'fabric' CLI that is a subset of the current 'peer' CLI","Using the 'peer' binary as the cli has caused much confusion. (At least it's confused me...) In addition to being used to interact with the orderer, it relies on configuration data from {{core.yaml}} - something that is intended to be consumed by a server side component.    We want to decouple the server side configuration from the client configuration and, in support of that goal, we want to move {{peer}} subcommands to a new {{fabric}} cli.    The new cli should support {{chaincode}}, {{channel}}, {{version}}, and {{lifecycle}} subcommands. The {{node}} command should not be present.    For this first phase, the behavior and configuration of the {{fabric}} sub-commands should be exactly the same as they are for the {{peer}} command. We will use this overlap to aid with the transition from {{peer}} to {{fabric}} in tests and other consuming components.",Story,Medium,Backlog,"2019-10-17 22:13:02","2019-10-17 22:13:02",3
"Hyperledger Fabric","Create a program that generates example configuration documents from annotated source","Using the configuration model, create a program that will generate a valid yaml document that contains the example and/or default configuration for a structure.    The program should be provided the name of the package containing the root structure and the name of the root structure type.    The doc comments for each field should be used to comment each of the configuration elements. Where the field name is used in the godoc, it is replaced with the name of the configuration key. The documentation should properly flow to an appropriate line width while still preserving blank lines from the godoc.",Story,Medium,Backlog,"2019-10-17 21:33:36","2019-10-17 21:33:36",5
"Hyperledger Fabric","Create a package that generates a model of configuration from the source tree","When provided with a reference to a go struct in the source tree, introspect the definition and generate a model that describes the configuration.    The model should include:  - The struct field name  - The struct field type  - The yaml key name of the configuration element  - The documentation comment associated with the field  - The example value for the field (if any)  - The default value for the field (if any) from the {{default}} or {{defaultValue}} tag  - For nested structs, an additional model object    As code comments need to be parsed, I expect {{go/ast}} and {{go/doc}} will be required to build the model.",Story,Medium,Backlog,"2019-10-17 21:28:46","2019-10-17 21:28:46",5
"Hyperledger Fabric","Generate user consumable documentation for external builder/fabric buildpack/external launcher","Create draft of documentation for the external build and launch infrastructure for Fabric. This should include introductory material, rationale, and reference data for implementors.    The documentation will need to be massaged by the technical writing team for Fabric and adapted for use in the correct locations.",Story,Medium,Closed,"2019-10-17 19:02:34","2019-10-17 19:02:34",2
"Hyperledger Fabric","Add support to the configuration package to honor defaultValue tags","As part of the drive to make configuration more centralized and explicit, configuration structures will be defined with {{yaml}} tags and, optionally, {{defaultValue}} tags.    The configuration package support for the {{default}} tag needs to be extended to support a {{defaultValue}} tag.  The {{defaultValue}} tag should reference an exported var that holds a literal containing the complex default value to use in configuration.    The difference is that the {{default}} tag is used to provide simple values to leaf nodes while {{defaultValue}} is used to provide complex literal defaults like structures or maps. Where possible, {{default}} should be preferred but there are a handful of places where {{defaultValue}} is required.    For example, decoding  {code:yaml}  ---  stringOne: one string      where {{Plugins}} is defined as:  {code:go}  type Plugins struct {   Name string `yaml:name`   Path string `yaml:path`  }      should result in a value that is equivalent to one that is decoded from this yaml:  {code:yaml}  ---  stringOne: one string  plugins:    - name: pluginOne    path: /path/to/one  - name: pluginTwo    path: /path/to/two  {code}    Notice the default values from the {{DefaultPlugins}} var are populated.",Story,Medium,Backlog,"2019-10-17 14:19:35","2019-10-17 14:19:35",2
"Hyperledger Fabric","Remove viper references from core/chaincode/config.go","{{chaincode.GlobalConfig}} re-initializes viper and uses it to acquire configuration data. Instead of loading the global config, the appropriate configuration data should be provided to the components out of peer/node/start.go.    The tests that continue to use viper to setup or query configuration that was part of the {{chaincode.Config}} struct should be updated to stop using viper.",Story,Medium,Backlog,"2019-10-14 21:07:05","2019-10-14 21:07:05",2
"Hyperledger Fabric","Decode core.yaml into peer configuration structure when starting the peer node or cli","Where viper is initialized today (in cmd/peer/main.go), using the new configuration package, parse {{core.yaml}} into the peer configuration structures. Explicitly pass the configuration to the command constructors to enable future changes that have the commands pull their configuration from the struct instead of viper.    The viper infrastructure should remain active to prevent modifications to tests and existing implementations that rely on environment variables.    Acceptance:     Parsing of existing core.yaml should be successful in the main.    Out of scope: removing viper from anything or rewiring to use the new config. Future stories/tasks will be created for that work.",Story,Medium,Backlog,"2019-10-14 20:59:34","2019-10-14 20:59:34",1
"Hyperledger Fabric","Replace configtxgen usage of viper with explicit decoding into yaml structures","The configtxgen packages use {{viper}} and {{viperutil.EnhancedExactUnmarshal}} to parse {{configtx.yaml}}. With the move away from viper, this should be replaced with vanilla yaml unmarshalling and path reference handling.    As there are a number of places where {{configtx.yaml}} uses maps of a user provided name to some structured data (instead of lists of structured data with names), there may be some complications.    It is extremely important that we do not break backward compatibility with the legacy configuration file format but we are removing the ability to override configuration data from environment variables.",Story,Medium,Backlog,"2019-10-14 20:48:39","2019-10-14 20:48:39",2
"Hyperledger Fabric","Create configuration package that is capable of decoding yaml into a structure and applying defaults from the default tag","As part of the drive to make configuration more centralized and explicit, configuration structures will be defined with {{yaml}} tags and, optionally, a {{default}} value tag.    We need a configuration package that implements a thin veneer over the yaml package to populate unspecified configuration data with values from the {{default}} tag when the yaml document does not specify a value.    For example, decoding  {code:yaml}  ---  stringOne: my special string      where {{Numbers}} is defined as:  {code:go}  type Numbers struct {   NumberOne int `yaml:numberOne default:1`   NumberTwo int `yaml:numberTwo default:2`  }      Notice the default values from the {{Numbers}} structure are populated.",Story,Medium,Backlog,"2019-10-14 20:28:14","2019-10-14 20:28:14",5
"Hyperledger Fabric","Create configuration package of structures that represent the current contents of orderer.yaml","Create an {{ordererconfig}} package that holds structures that {{orderer.yaml}} can be decoded into. Several small structures will be required to hold the elements that are aggregated in stanzas.    The godoc for each field will become the user consumable documentation (where the field name is rewritten to the configuration key) so care should be taken to make it as clear as possible.    Each field needs yaml, default, and example tags as appropriate.     The {{yaml}} tag controls the yaml encoding and decoding process as documented by go-yaml.  The {{default}} tag determines the default configuration value. When omitted, the zero value for the field is the default value for the element.  The {{example}} tag determines the value to provide in the example configuration document. If the value is not specified, the default value will be used in the example document. If the example should show the field as commented, the specification can end with a {{,comment}} flag.    An example:        A {{defaultValue}} tag can be used to reference an exported var that holds the default structure by providing the name of the variable. The variable must be in the same package.",Story,Medium,Backlog,"2019-10-14 20:00:12","2019-10-14 20:00:12",2
"Hyperledger Fabric","Create configuration package of structures that represent the current contents of core.yaml","Create a {{peerconfig}} package that holds structures that {{core.yaml}} can be decoded into. Several small structures will be required to hold the elements that are aggregated in stanzas.    The godoc for each field will become the user consumable documentation (where the field name is rewritten to the configuration key) so care should be taken to make it as clear as possible.    Each field needs yaml, default, and example tags as appropriate.     The {{yaml}} tag controls the yaml encoding and decoding process as documented by go-yaml.  The {{default}} tag determines the default configuration value. When omitted, the zero value for the field is the default value for the element.  The {{example}} tag determines the value to provide in the example configuration document. If the value is not specified, the default value will be used in the example document. If the example should show the field as commented, the specification can end with a {{,comment}} flag.    An example:        A {{defaultValue}} tag can be used to reference an exported var that holds the default structure by providing the name of the variable. The variable must be in the same package.",Story,Medium,Backlog,"2019-10-14 19:59:46","2019-10-14 19:59:46",2
"Hyperledger Fabric","Remove the provisional system channel genesis block support from the orderer","The generation of a system channel genesis block is not a core function of the orderer. Even though it could be somewhat useful in test environments, from a technical perspective, it requires the orderer to include and use the sample {{configtx.yaml}} in addition to the orderer's own {{orderer.yaml}}.    From a process and deployment perspective, it's better to have the system channel genesis block explicitly created by administrators with real names than to rely on fixtures that were originally intended for test.    For these reasons, we should remove the provisional genesis method from the orderer, it's associated artifacts, and documentation. The removal should be highlighted in release notes.    Acceptance: code supporting provisional is gone, documentation for the feature is removed, and a release note highlighting the removal is created.",Story,Medium,Closed,"2019-09-27 18:27:23","2019-09-27 18:27:23",3
"Hyperledger Fabric","Ensure that go chaincode can be used with the release 1.4 ccenv","With the removal of the fabric/chaincode/shim and dependencies from the v2 ccenv, chaincode packaged for previous releases can't be built with by a 2.0 peer.    It's inevitable that previously built chaincode docker images will be removed and, when that happens, the previously installed 1.x chaincode will need to be built by a 2.x peer. This will fail for go chaincode when using the 2.x version of ccenv.    To help get out of this mess, we need to verify that the peer can be successfully configured to use the hyperledger/fabric-ccenv-1.4 as the builder image.    /cc [~<USER>, [~<USER>",Story,Medium,Closed,"2019-09-27 17:37:01","2019-09-27 17:37:01",2
"Hyperledger Fabric","Consistently provide PEM encoded keys and certificates to chaincode platform implementations","[~<USER> highlighted something about the launch contract that we should try to address moving forward.    The client key and client cert that we provide to the chaincode are base64 encoded PEM blocks while the root certificate is simply the PEM block.    The base64 encoding of the PEM blocked (already encoded) certificate is really weird... Unfortunately, we can't just change it as existing chaincode will be decoding so we need to add mitigation/migration.    [https://github.com/hyperledger/fabric-chaincode-go/blob/8f8a45e6039e7bc0e03a042591b010317481f21d/shim/internal/config.go#L48-L67]    The thought is that we can create two new files that contain the pem blocks (instead of base 64 encoded pem blocks) and use new keys to reference them. The old config and format would be deprecated and ultimately removed.    This will impact the run step of the launcher as well (in a different story)...    The go shim should be updated to prefer the non-double-encoded certificates. Node and java should not.    Acceptance: I can run chaincode build with the old and new go chaincode shim.",Story,Medium,Closed,"2019-09-19 19:16:58","2019-09-19 19:16:58",2
"Hyperledger Fabric","As a fabric developer, I expect my GOPROXY configuration to be honored during test","in module mode, go will often access remote VCS repositories to validate pinned versions are valid with respect to expectations at the time the go.sum file was written. Alternatively, if a go.sum is not written, the repositories will be accessed to check for version information and tags. This is expensive.    To reduce the cost, go can be configured to point to a proxy that hosts indexes for packages and calculated sums. The google go team hosts proxy.golang.org for publicly accessible repositories.    Acceptance: During build and test, if I have {{$GOPROXY}} configured, it uses my configuration. This includes containerized chaincode builds. If the proxy is not explicitly configured, it should be conditionally set to [https://proxy.golang.org|https://proxy.golang.org/].    In addition to inheriting and honoring the calling environment, this should allow end-users to provide their own proxy configuration when using private repositories.    The environment variable only *needs* to be set for the golang platform.   Integration test configuration should whitelist GOPROXY.",Story,Medium,Closed,"2019-09-13 14:01:05","2019-09-13 14:01:05",2
"Hyperledger Fabric","As a Fabric contributor, I'd like a more standard project layout","See [https://github.com/golang-standards/project-layout] for what we want to strive for here.    We need to stop using core, common, etc and move to more standard pkg, internal, internal/pkg, etc structure",Story,Medium,Backlog,"2019-08-27 14:39:40","2019-08-27 14:39:40",4
"Hyperledger Fabric","As a consumer of fabric samples, I expect go chaincode to use fabric-protos-go and fabric-chaincode-go","Update fabric-samples.",Story,Medium,Closed,"2019-08-23 18:09:45","2019-08-23 18:09:45",1
"Hyperledger Fabric","As a fabric developer, I want to consume the go protobuf bindings that live in fabric-protos-go",,Story,Medium,Closed,"2019-08-21 22:59:23","2019-08-21 22:59:23",1
"Hyperledger Fabric","Add an integration test for failing instantiation policy","The security check that renders the 1.x lifecycle its security guarantees is the instantiation policy.  However, to my knowledge, nowhere in our integration tests do we actually verify that violating the instantiation policy prevents chaincode execution.  It is very likely that a custom RW set will need to be generated in order to exercise this path.",Story,Medium,Closed,"2019-08-12 18:23:37","2019-08-12 18:23:37",3
"Hyperledger Fabric","External builders should run in controlled environment","By default, when a process is started, it inherits the environment of its caller. In the context of external chaincode, the environment of the peer is propagated to the builder. Given most users of the peer rely on environment variables to influence the configuration, it's quite likely that sensitive information is accessible in the environment.    In order to reduce the likelihood of information leaks via the environment, the external build configuration element in the peer should be extended to support and environment variable name whitelist. Any environment keys in that list will be propagated to the external builder.    The default list should contain PATH, LIBPATH, and TMPDIR. It's likely that environment variables like http_proxy/HTTP_PROXY will be added by users.",Story,Medium,Closed,"2019-08-06 21:40:25","2019-08-06 21:40:25",2
"Hyperledger Fabric","External builder launch should not need to parse flags","The first pass of the detect, compile, launch infrastructure was implemented with a collection of  command line switches. This will become unwieldy over time as implementers will have difficulties ignoring unknown flags and parameters - especially flags that accept values.    Instead we should remain consistent with the buildpack model that already exists - namely, we provide a list of directories that contain extracted files. If we need to provide more data, we can add an additional argument or populate additional files. This means that implementations should ignore extra arguments as a general rule until they know what they point to.    launch receives directory containing metadata, the source the directory, the output directory from build, and an artifacts directory that contains file necessary for launch (key, cert, address, etc.). The artifacts must have well known names.    Acceptance: external scripts do not need to process flags; existing parameters are reworked to fit this model.",Story,Medium,Closed,"2019-08-05 16:34:04","2019-08-05 16:34:04",3
"Hyperledger Fabric","External builder build should not need to parse flags","The first pass of the detect, compile, launch infrastructure was implemented with a collection of  command line switches. This will become unwieldy over time as implementers will have difficulties ignoring unknown flags and parameters - especially flags that accept values.    Instead we should remain consistent with the buildpack model that already exists - namely, we provide a list of directories that contain extracted files. If we need to provide more data, we can add an additional argument or populate additional files. This means that implementations should ignore extra arguments as a general rule until they know what they point to.    build should receive receive arguments for the metadata directory, a directory containing the extracted source, and a directory for it to store its output.    Acceptance: external scripts do not need to process flags; existing parameters are reworked to fit this model.",Story,Medium,Closed,"2019-08-05 16:33:31","2019-08-05 16:33:31",3
"Hyperledger Fabric","Remove pkg/errors dependency from shim/ext packages",,Task,High,Closed,"2019-08-05 15:12:29","2019-08-05 15:12:29",1
"Hyperledger Fabric","Remove ext/entities from the go chaincode packages","The dependency on bccsp prevents proper structuring of the code and will result in a rewrite of the package. The proposal from [~<USER> is to remove the code and, if we need to recreate it, we can do it when the package has been extracted from fabric.    Acceptance: there are no fabric dependencies in shim extensions other than the protos.",Story,Medium,Closed,"2019-08-05 14:54:12","2019-08-05 14:54:12",2
"Hyperledger Fabric","External builder detect should not need to parse flags","The first pass of the detect, compile, launch infrastructure was implemented with a collection of  command line switches. This will become unwieldy over time as implementers will have difficulties ignoring unknown flags and parameters - especially flags that accept values.    Instead we should remain consistent with the buildpack model that already exists - namely, we provide a list of directories that contain extracted files. If we need to provide more data, we can add an additional argument or populate additional files. This means that implementations should ignore extra arguments as a general rule until they know what they point to.    detect should be provided a directory containing metadata.json (holding metdata as a basic map) and a reference to a directory containing the exploded source.    Acceptance: external scripts do not need to process flags; existing parameters are reworked to fit this model.",Story,Medium,Closed,"2019-08-02 19:29:52","2019-08-02 19:29:52",3
"Hyperledger Fabric","Properly sanitize packageIDs for the externalbuilder build context temporary directory stem","See https://gerrit.hyperledger.org/r/c/fabric/+/32416/11/core/container/externalbuilders/externalbuilders.go#26    When creating the temporary directory, remove any character other than alphanumeric characters. This will address path separators and special characters that may need special treatment by scripts (eg. >< ! $ &, etc).",Story,Medium,Closed,"2019-07-26 18:22:20","2019-07-26 18:22:20",1
"Hyperledger Fabric","As a fabric developer, I need a way to stop chaincodes built and launched by the externalbuilder","This is currently ill defined, and we may decide that it is invalid.  Still, with existing chaincodes, particularly the docker ones, it is possible to stop a chaincode.  This is useful in integration style tests, and, would be nice to have for when a chaincode is no longer referenced in any channels, we could automatically stop it to conserve resources.  For this latter bit, we have seen users who deploy many iterations of a chaincode in development, and resource exhaust their machines as all copies remain running.",Story,Medium,Closed,"2019-07-26 18:15:34","2019-07-26 18:15:34",2
"Hyperledger Fabric","As a fabric operator, I need to see the output of the externalbuilders in the peer logs","The assorted external builder components (detect, build, and launch), all currently lose the output of the commands.  For debugging build failures, or failures to detect etc., we should stream the standard error output of these invocations back to the peer logs.    Note: standard out will be reserved for communication with the process.    Acceptance: the output of 'detect', 'build', and 'launch', can be seen at debug level.  The output of 'build' and 'launch' can be seen at warning level when there is a failure. The log records should include some information about which process is generating the output.",Story,Medium,Closed,"2019-07-26 18:13:15","2019-07-26 18:13:15",3
"Hyperledger Fabric","As a Fabric user, I want to instantiate chaincode using the CLI with a policy requiring multiple orgs","    does not support the {{--peerAddresses}} flag which is needed when using instantiation policies which require more than one org.",Story,Medium,Closed,"2019-07-22 15:57:53","2019-07-22 15:57:53",2
"Hyperledger Fabric","Remove fabric dependencies from shim/ext packages","As a consumer of the entities package, I want to avoid dependencies fabric packages and   their transitive dependencies.        *go list -f '{{join .Deps \n}}' ./core/chaincode/shim/ext/entities/... | sort -u* drags in        ",Story,Medium,Closed,"2019-07-19 13:24:36","2019-07-19 13:24:36",2
"Hyperledger Fabric","Create fabric-protos-go repository and populate it with boilerplate","Create a new github repository called {{fabric-protos-go}} and populate it with a {{protos}} directory that contains the fabric {{protos}}, the necessary LICENSE, CODE_OF_CONDUCT.md, CONTRIBUTING.md, and README.md.    This repository should not be a read-only mirror of gerrit but a simple github repo.    The repository should be configured not to accept pull requests (stale-bot or settings). The fabric release managers should be configured with write access to handle unexpected issues that may arise.",Story,Medium,Closed,"2019-07-15 16:42:05","2019-07-15 16:42:05",2
"Hyperledger Fabric","As a user of the fabric tools (eg. protolator), I would like to see human consumable versions of the proto encoded kv ledger structs","The ledger currently maintains a small number of protobuf files outside of the protos tree. The goal was to prevent these from being consumed as fabric api but, in reality, they're used in the blockchain marshaling and, as such, are part of the surface area of the project.    In order to enable tools outside of the core fabric tree to decode and use these datatypes, the protos should be promoted into the protos tree, the bindings should be generated from there, and the ledger component updated to pull in the new imports as appropriate.    Acceptance: protos are in a sub-directory of the {{protos}} tree and the generated go bindings live in a package rooted under {{protos}}.",Story,Medium,Closed,"2019-07-15 16:19:05","2019-07-15 16:19:05",2
"Hyperledger Fabric","As a fabric developer, I want to explicitly manage references to the default BCCSP implementation","There are number of places where {{bccsp/factory#GetDefault()}} is used to get a BCCSP implementation. Each call site should be evaluate in context.    Where an actual implementation is needed, instead of asking for the implementation, the required instance should be explicitly provided and wired to the consumer.    Where the implementation is being used for software crypto operations in test, consider replacing it with basic go crypto.    As of current master, the following packages seem to be impacted:        Acceptance: {{bccsp.GetDefault}} and its associated package level state is gone or an unprioritized story has been created that details the complexity involved in removing the reference.",Story,Medium,Closed,"2019-07-13 01:02:04","2019-07-13 01:02:04",3
"Hyperledger Fabric","Remove fabric dependencies from shim/ext/statebased","As a consumer of the statebased package, I want to avoid dependencies on fabric/comm, fabric/protoutil, pkg/errors, and their transitive dependencies.    {go list -f '{{ join .Deps \n }}' ./core/chaincode/shim/ext/statebased} show the following fabric packages are dependencies of the statebased package. Most of these are transitive deps that are pulled in by references to {{common/cauthdsl}}.    The {{protoutil}} import drags in deps on {{internal/pkg/identity}}.        Acceptance: The only fabric imports are the protos.",Story,Medium,Closed,"2019-07-13 00:47:27","2019-07-13 00:47:27",2
"Hyperledger Fabric","As a chaincode developer, I would like the chaincode shim to require the minimal set of dependencies","The current chaincode shim depends on a number of fabric packages. We need to isolate and remove the dependencies on these packages so we can move the chaincode shim to a separate repository that only relies on:    - go standard library  - grpc and its direct dependencies  - fabric protobuf definitions    In particular, {{go list -f '{{join .Deps \n}}' ./core/chaincode/shim | sort -u}} shows that the following fabric packages are imported:        Acceptance: The only remaining dependencies on code from the hyperledger/fabric repo are proto bindings for messages.    With respect to comm, we will explicitly code the default values of the client side options for grpc. If we need to export the ability to configure these, we'll do that later and in a separate story.",Story,Medium,Closed,"2019-07-13 00:12:05","2019-07-13 00:12:05",3
"Hyperledger Fabric","As a consumer of fabric-protos, I expect go language bindings to be available in fabric-protos-go","When protobuf definitions are updated in {{fabric-protos}}, an automated build process should be triggered to compile the protos to go and commit the generated artifacts to a separate source repository that gets used by or vendored into consumers. The {{fabric-protos}} repository will not contain the generated language bindings.    We have a couple of options to discuss for placement:    1. Create a {{fabric-protos-go}} repository to contain the compiled protocol buffer bindings for go. In this scenario, the import paths for the various protobuf packages would be {{github.com/hyperledger/fabric-protos-go/[common,discover,peer,orderer,etc]}}. This repo should be configured not to accept pull requests. The contents should be managed by automation.(Preferred.)  -2. Reuse the {{fabric-lib-go}} repository. In this scenario, the import paths would all be under a common {{protos}} folder and would be {{github.com/hyperledger/fabric-lib-go/protos}}.-    In either case, pull request builds for {{fabric-protos}} should generate but *not* merge/commit the artifacts to the target repo. Builds performed post-commit should generate the artifacts and commit them to the target repo.    Update: During IPM we decided to do the build and promote with Travis-CI.    [1:] Please consider branching strategies. {{fabric-protos/release-2.0}} should promote to {{fabric-protos-go/release-2.0}} while {{fabric-protos/master}} should promote to {{fabric-protos-go/master}}.  [2:] Please read https://medium.com/namely-labs/how-we-build-grpc-services-at-namely-52a3ae9e7c35 for inspriation.    ",Story,Medium,Closed,"2019-07-12 23:14:18","2019-07-12 23:14:18",3
"Hyperledger Fabric","Create fabric-protos repository and populate it with fabric protos","Create a new github repository called {{fabric-protos}} and populate it with a {{protos}} directory that contains the fabric {{protos}}, the necessary LICENSE, CODE_OF_CONDUCT.md, CONTRIBUTING.md, and README.md.    This repository should not be a read-only mirror of gerrit but a simple github repo.    The repository should be configured to provide write access to the fabric maintainers. This will likely require the definition of a new github team.",Story,Medium,Closed,"2019-07-12 22:45:15","2019-07-12 22:45:15",2
"Hyperledger Fabric","Replace custom pkcs11 implementation with ThalesIgnite/crypto11","https://github.com/ThalesIgnite/crypto11 provides a nice wrapper around miekg/pkcs11 for exposing the standard crypto.Signer interface",Task,Medium,Backlog,"2019-07-04 12:23:57","2019-07-04 12:23:57",3
"Hyperledger Fabric","Deprecate SOLO orderer in favor of single node raft",,Story,Medium,Closed,"2019-06-18 19:43:55","2019-06-18 19:43:55",1
"Hyperledger Fabric","Remove / deprecate RSA crypto and options in bccsp",,Story,Medium,Closed,"2019-06-18 19:43:30","2019-06-18 19:43:30",2
"Hyperledger Fabric","As a chaincode developer, I want {{chaincode package}} to honor *all* of my dependencies","The {{chaincode package}} command includes some logic to filter packages that the ccenv includes. This means that older or newer versions of these packages (used during development) will not be included in the package that's installed to the peer.    As a developer, when the auto-vendoring process is performed, I would like my code to be included at all times.",Story,Medium,Closed,"2019-06-17 16:23:28","2019-06-17 16:23:28",2
"Hyperledger Fabric","Allow orderer startup with no channels defined","Today, if the orderer does not have any channels defined, it panics because it cannot find the system channel.  This story is to remove those startup checks to allow the orderer to start successfully, even though it will not be in a position to accomplish anything.  This should also block channel creation requests if no system channel is defined to route them to.",Story,Medium,Closed,"2019-06-13 16:39:16","2019-06-13 16:39:16",2
"Hyperledger Fabric","Add 'None' genesis method for orderer configuration","Today, the orderer may be given one of two genesis methods 'Provisional' or 'File'.  In the 'Provisional' case (useful only for testing) the orderer generates a genesis block based on a configtx.yaml file, while in the 'File' case, the orderer loads a file from the filesystem.    In order to ultimately allow the orderer to start without chains defined, we need to allow a genesis method which does not attempt to do anything.  This genesis method should be called 'None', and should not trigger loading of the genesis file, nor generation of a genesis block.    ----    If you supply None as the genesis method for an orderer that has not been bootstrapped, the orderer should panic.  If you supply None as the genesis method for an orderer that has already been bootstrapped and the genesis file is not available, it should start normally.  ",Story,Medium,Closed,"2019-06-13 16:37:44","2019-06-13 16:37:44",2
"Hyperledger Fabric","Convert cscc functionality to proper gRPC API","It really does not make sense that peer config options be implemented as system chaincode (cscc).  It would be cleaner to expose a set of nice APIs.   We can still require the requests to be signed and can enforce ACLs.",Story,Medium,Backlog,"2019-05-20 12:27:15","2019-05-20 12:27:15",2
"Hyperledger Fabric","Convert qscc functionality to proper gRPC API","It really does not make sense that the functionality for retrieving chain information is implemented as system chaincode (qscc).  It would be cleaner to expose a set of nice APIs for retrieving this information.   We can still require the requests to be signed and can enforce ACLs.",Story,Medium,Backlog,"2019-05-10 11:28:08","2019-05-10 11:28:08",2
"Hyperledger Fabric","Address remaining test comments from https://gerrit.hyperledger.org/r/c/31076/4","Comments regarding the assertions in {{TestSelectClusterBootBlock}} need to be addressed.  Gerrit has the details but here are the comments:    {quote}  I think you either want to use assert.Same(t, bootstrapBlock, clusterBlock) so ensure you're getting back the exact same instance (ptr value) or just use assert.Equal(t, bootstrapBlock, clusterBoot) to ensure that the values pointed to are equal. The header number assertion is implied with the equality check.    Unrelated but for awareness (you may already know) - if proto objects get marshaled/unmarshaled, assert.Equals won't necessarily work and you'll have to use proto.Equal to check the values.  {quote}",Sub-task,Medium,Closed,"2019-04-30 15:58:52","2019-04-30 15:58:52",1
"Hyperledger Fabric","first-network should only spin up nodes","The *first-network* sample attempts to be everything to everybody and it is going to crater soon.  *first-network* should actually just spin up the various nodes (it's ok to generate the required crypto material).  It should not:       * create channels   * install chaincode   * instantiate chaincode   * invoke / query chaincode         We can then decide how to build tutorials for performing those actions.  Doing all of these things through various scripts really does not help demonstrate how to actually perform these actions.  There actually tutorial-like documentation about the samples ... this just needs to be modified to actually be a real tutorial.",Story,Medium,Backlog,"2019-04-07 13:17:59","2019-04-07 13:17:59",3
"Hyperledger Fabric","As a fabric operator, I want a custom builder to be invoked when my detect script exits normally","Acceptance:    I can drop a {{build}} script the peer's local file system next to the {{detect}} script. When the {{detect}} script  exits successfully, the {{build}} script will be called. The arguments to the build script should be the extracted contents of the chaincode package, a directory to place chaincode metadata for the peer (ie. CouchDB index files), and a directory to place assets that may be needed to launch chaincode.    If the {{build}} script exits abnormally, the build process has failed.",Story,Medium,Closed,"2019-03-05 14:23:00","2019-03-05 14:23:00",3
"Hyperledger Fabric","As a fabric operator, I want the peer to execute a binary I configure to determine if a custom builder should be used","Acceptance:    I can add keys to {{core.yaml}} that point to a path in the peer's local file system that contains a {{detect}} binary. If it exits, it is called prior to building chaincode. No further action is required.    System chaincode never uses the external launcher.",Story,Medium,Closed,"2019-03-05 14:17:58","2019-03-05 14:17:58",3
"Hyperledger Fabric","Fabric uses a third-party Docker client, should be replaced with official Docker client","Fabric currently uses the fsouza, 3rd party Docker client. At the time of vendoring, this was the mainstream Docker client for Go. There is now an official Docker Client for Go, and the fsouza repo now states you should use this moving forward, as the fsouza client will no longer guarantee support for Docker updates.",Story,Medium,Closed,"2019-01-28 14:45:11","2019-01-28 14:45:11",2
"Hyperledger Fabric","As a developer, I want to our 1.4 stream to build against the latest release of go 1.11","The current version of 1.11 is 1.11.5 and includes security related fixes for crypto/elliptic.    We need to bump the version of go that we build with in fabric, fabric ca, our docker images, and all of the other miscellaneous places - including our build environments in CI.",Story,Medium,Closed,"2019-01-25 15:56:08","2019-01-25 15:56:08",2
"Hyperledger Fabric","As a developer, I want to use go 1.11.5 while developing on master","The current version of 1.11 is 1.11.5 and includes security related fixes for crypto/elliptic.    We need to bump the version of go that we build with in fabric, fabric ca, our docker images, and all of the other miscellaneous places - including our build environments in CI.",Story,Medium,Closed,"2019-01-25 15:55:18","2019-01-25 15:55:18",2
"Hyperledger Fabric","As a fabric developer, I want to be able to test changes to fabric-lib-go","The {{fabric-lib-go}} repository needs to have build scripts or a makefile added that can be used to test and validate change requests.",Story,Medium,Closed,"2019-01-21 15:46:21","2019-01-21 15:46:21",1
"Hyperledger Fabric","As a developer, I want a Jenkins job configured to build and test fabric-lib-go changes","The {{fabric-lib-go}} project exists in Gerrit but is not associated with a Jenkins build. A build needs to be defined that is triggered on Gerrit CRs.",Story,Medium,Closed,"2019-01-21 15:43:31","2019-01-21 15:43:31",2
"Hyperledger Fabric","Expose orderer blockcutter metrics","The only real tunables for the orderer as far as latency and throughput  goes is the batch parameters.  Therefore, it's critical for network  operators to be able to gain insight into the duration filling a block  takes to know whether they should relax or tighten their batch  parameters.",Task,Medium,Closed,"2018-11-30 03:53:24","2018-11-30 03:53:24",1
"Hyperledger Fabric","fabric-tools image used as a 'cli' container should have a non-root user","* Observed root permissions are settingup after execute this step *{{DEVMODE=false gulp channel-init}}*          ",Story,Medium,Backlog,"2018-11-13 18:00:51","2018-11-13 18:00:51",2
"Hyperledger Fabric","System Behave Framework: Add the ability to revoke certificates using fabric-ca","fabric-ca has the ability to revoke certificates for a person as well as an organization. This ability needs to be added and tested.",Story,Medium,Closed,"2018-11-03 11:36:52","2018-11-03 11:36:52",5
"Hyperledger Fabric","Only perform npm install at the beginning of test suite and not test cases","The system behave tests perform a npm install every time the Node SDK is used. Time can be saved and consistency ensured by performing an npm install once at the beginning of the test suite, then whenever the Node SDK is used, the node_modules directory is already in place.     Care must also be taken to ensure that the node_modules directory is not deleted at the end of each test run.    Performing this change will shave minutes off of the smoke and daily test runs.",Story,Medium,Closed,"2018-10-01 14:06:22","2018-10-01 14:06:22",1
"Hyperledger Fabric","Update Read The Docs Testing page with Interoperability Info","The Read The Docs page needs to be updated with Interoperability details.",Task,Medium,Closed,"2018-08-23 14:10:44","2018-08-23 14:10:44",1
"Hyperledger Fabric","As a Fabric application developer, I'd like to build browser-based applications which directly interact with Fabric nodes","The core Fabric APIs are gRPC-based.  This makes it difficult to directly interact with Fabric nodes from web browsers as gRPC makes use of parts of the HTTP/2 spec which are not currently supported in web browsers.  Today, many people try to put REST servers in front of Fabric nodes which is OK but has multiple issues in terms of protocol translation and even key management.",Story,High,Backlog,"2018-08-22 16:14:09","2018-08-22 16:14:09",3
"Hyperledger Fabric","As a token-based system client developer, I can request from a peer to compute a token redemption proof matching my token redemption needs","{color:#333333}*Acceptance:* A client function (cwLib) takes as arguments the identifiers of tokens to be redeemed via a token redemption process. As a result the function would request from a peer to construct the corresponding token redemption proof. {color}    The redemption proof is returned to the client and the function will return successfully only if the returned issue proof is correctly computed.",Story,Medium,Closed,"2018-08-22 09:50:44","2018-08-22 09:50:44",5
"Hyperledger Fabric","Use dynamically allocated ports for tests in core/comm package","Rather than specifying a fixed  host:port combination for tests, should leverage dynamic port assignment using localhost:0 syntax",Task,Medium,Closed,"2018-08-21 08:33:43","2018-08-21 08:33:43",1
"Hyperledger Fabric","Add round trip usage of the new chaincode install and query installed chaincodes function to e2e","With the implementation of the peer chaincode package, peer chaincode install, and peer chaincode list for the new lifecycle, it should be possible to test these using the e2e framework.    There is likely no need to create an entire new suite for this with a new network, but extending an existing suite should be straightforward.    The test should package a chaincode, install that package, and verify that the package is returned as installed.",Task,Medium,Closed,"2018-08-10 06:49:23","2018-08-10 06:49:23",2
"Hyperledger Fabric","As a fabric admin, I need a way to query installed chaincode packages from the new lifecycle.","This story is to extend the existing 'peer chaincode list command to support listing installed chaincodes via the new chaincode API.    The operation should be the same as before, but it should add a new '-N' parameter to indicate that the new lifecycle should be utilized, instead of the old.  It should invoke the '+lifecycle.QueryInstalledChaincodes' API, and print a list of name, version, hash.    Note, for the time being it is necessary to only allow querying installed chaincodes with '-N', the instantiated chaincodes will be covered in another story.",Story,Medium,Closed,"2018-08-10 06:46:48","2018-08-10 06:46:48",2
"Hyperledger Fabric","As a fabric admin, I need a way to install a new chaincode package.","This is to exercise the new +lifecycle.InstallChaincode API.    It should extend the existing 'peer chaincode install' command.  It should require that a package be provided as input (to avoid non-deterministic multiple-packaging), and invoke SCC function.  It should require the 'name' and 'version' parameters, but the 'language' and 'path' parameters should not be allowed.     Like the other new lifecycle commands, it should distinguish itself from the old APIs by requiring a -N parameter.",Story,Medium,Closed,"2018-08-10 06:44:03","2018-08-10 06:44:03",3
"Hyperledger Fabric","As a fabric admin, I need a way to inspect the new chaincode package format.","Because in the new lifecycle scheme, we will require that the package hashes are consistent, users will need to share chaincode packages.  However, there should be no centralized point of trust, so each user should be able to verify that the chaincode package contains the expected code.    Therefore, we need to extend the peer chaincode package command to be able to extract a chaincode package and write it out to disk.      This should be accomplished with a new chaincode sub-command 'inspectpackage'.  It should take a path to the chaincode package, and optionally a location to extract it to (defaulting to the current directory).  It should then extract the embedded code package.",Story,Medium,Closed,"2018-08-10 06:40:46","2018-08-10 06:40:46",3
"Hyperledger Fabric","As a chaincode admin, I need to be able to package in the new chaincode format using the peer CLI.","We need to add the ability to package chaincode in the new chaincode package format for the updated lifecycle.    This should come in the form of an extension to the peer chaincode package command.  It should take the same options for 'language' (type), and 'path', but it should refuse to allow the 'name', 'version', or 'instantiation policy' to be specified.  Additionally, the '-s' flag should not be allowed.    As with all peer chaincode commands utilizing the new chaincode lifecycle, it should indicate that the new lifecycle should be used with the flag -N' for use of the new +lifecycle chaincode.    The operation should package the code along with the type and path into the new tar gz chaincode package format and write it to disk.",Story,Medium,Closed,"2018-08-10 06:35:59","2018-08-10 06:35:59",3
"Hyperledger Fabric","As a fabric admin, I need a way to query the currently installed chaincode packages",,Story,Medium,Closed,"2018-08-10 06:21:58","2018-08-10 06:21:58",1
"Hyperledger Fabric","Update Test documentation","The documentation for testing needs to be updated to include the Integration information. This is for read-the-docs (RTD) as well as a README in the integration folder.",Task,Medium,Closed,"2018-08-06 13:55:36","2018-08-06 13:55:36",1
"Hyperledger Fabric","As a token infrastructure (peer) developer, I would like to implement the processing of TLS-authenticated client requests ","Prover peer grpc service is now ready to fully process TLS-authenticated client requests to for proof computation. At the end of this item acceptance criteria of the parent item should be fulfilled.",Story,Medium,Closed,"2018-07-27 14:13:42","2018-07-27 14:13:42",5
"Hyperledger Fabric","As a token-based application/client developer, I can submit a transaction for  issuing new tokens into the system","Here the client token library leverages the responses from the prover peer to create a token transaction for issue that is submitted to the ordering service.",Story,Medium,Closed,"2018-07-25 10:46:24","2018-07-25 10:46:24",5
"Hyperledger Fabric","As a token-based application/client developer, I can create and submit a transaction to request the  transfer of my tokens","Here the client token library leverages the responses from the prover peer to create a token transaction for transfer that is submitted to the ordering service.",Story,Medium,Closed,"2018-07-25 10:44:06","2018-07-25 10:44:06",2
"Hyperledger Fabric","As a token system client developer, I can request from a peer to compute a transfer proof matching my transfer token needs","{color:#333333}Acceptance: A client function (cwLib) takes as arguments the identifiers of the tokens {color}{color:#333333}to be transferred and the expected recipients. As a result the function would request from a peer to construct the corresponding transfer proof. The transfer proof is returned to the client and the function will return successfully only if the returned transfer proof is correctly computed.{color}  {color:#333333} {color}",Story,Medium,Closed,"2018-07-25 10:41:54","2018-07-25 10:41:54",2
"Hyperledger Fabric","As a token-based application/client developer, I can query  the ledger through a peer I trust to list my tokens into the system ","*Acceptance*: Client wallet library for token operations in Fabric is enhanced with a function that takes as arguments the long term identity of an end-user and queries a peer on the set of tokens that this end-user owns. The peer receives the request and acts according to the specification of previous story.",Story,Medium,Closed,"2018-07-25 10:40:27","2018-07-25 10:40:27",2
"Hyperledger Fabric","As a token-based system client developer, I can request from a peer to compute an issue proof matching my issue needs ","{color:#333333}{color:#333333}Acceptance: A client function (cwLib) takes as arguments the type and quantity of assets to be introduced into the system via a token issue process. As a result the function would request from a peer to construct the corresponding issue proof. {color}{color}  {color:#333333} {color:#333333}The issue proof is returned to the client and the function will return successfully only if the returned issue proof is correctly computed.{color}{color}",Story,Medium,Closed,"2018-07-25 10:33:20","2018-07-25 10:33:20",2
"Hyperledger Fabric","As a  token infrastructure (peer) developer, I want to accommodate “list of my tokens” requests","*Acceptance*: A fabric client can be built to submit a “list tokens” query to a peer.  Peer considers the current ledger state and returns the tokens owned by the   creator of the query; if the creator of the query does not have permission to read  the channel’s data, the request is rejected; if the creator of the query does not own  any tokens the peer would return an empty list. The client can observe the correctness  of successive “list my tokens” queries in correlation with the content of the ledger.",Story,Medium,Closed,"2018-07-25 09:56:42","2018-07-25 09:56:42",2
"Hyperledger Fabric","As a token infrastructure (peer) developer, I want the peer to accommodate requests to compute an issue proof given specific parameters","*Acceptance*: A (simulated) client constructs a request to construct an issue proof by   providing the type and quantity of assets to be introduced into the system, and invokes   the peer API. The peer would need to construct the corresponding issue proof and return   it to the (simulated) client. Acceptance would require that the constructed proof matches   the input parameters of the request.",Story,Medium,Closed,"2018-07-25 09:52:38","2018-07-25 09:52:38",3
"Hyperledger Fabric","As a token infrastructure (committing peer) developer, I can fully process a “transfer tokens  transaction ","Given FAB-11942, and FAB-11371 this item refers to the testing that the transfer transactions can be correctly processed by the existing tx processor and TMS implementation.",Story,Medium,Closed,"2018-07-25 09:42:58","2018-07-25 09:42:58",2
"Hyperledger Fabric","As a token infrastructure (committing peer) developer, I can recognise and process a  “transfer tokens transaction without impacting the ledger state","*Acceptance*: A (simulated) client generates a “transfer tokens transaction.    Upon receiving this transaction, a committing peer redirects its processing to its    FabToken specific validation & commit components.  The transaction is to be   marked as invalid in the end and will have no impact on the ledger state.         This one relates to the extension of proto messages to accommodate transfer   transactions and of the corresponding test, testing that transfer token transactions   go through the right path.    The first part was already completed (proto messages definition). The second is   blocked by  FAB-11175.",Story,Medium,Closed,"2018-07-25 09:38:55","2018-07-25 09:38:55",2
"Hyperledger Fabric","As a token infrastructure (committing peer) developer, I can fully process an issue tokens  transaction ","   *Acceptance*: A (simulated) client generates an issue tokens transaction that is submitted  to the system.  Upon receiving this transaction, a committing peer redirects its processing to its   Token specific validation & commit components.  FabToken custom validation ensures that  the tokens requested to be issued are of the right form (e.g., of acceptable type), and custom   commit ensures that the transaction creator is authorised to issue tokens.  Upon successful  transaction validation and commit, the ledger state is updated to reflect this. The ledger APIs   can be used to retrieve the committed data. ",Story,Medium,Closed,"2018-07-25 08:59:25","2018-07-25 08:59:25",5
"Hyperledger Fabric","As a token application developer, I want to initialise a simplified Token client library using sample FabToken parameters without signing abilities","{color:#333333}Acceptance: I can setup the token client library using a fixed set of token parameters, and monitor the internal state of the created client to ensure that its initialization took place with the right parameters. The client library would not provide any further functionality at this point beyond setup.{color}",Story,Medium,Closed,"2018-07-25 08:32:17","2018-07-25 08:32:17",3
"Hyperledger Fabric","As a token infrastructure developer, I want the committing peers to setup a Token-specific validation and transaction processor components using a fixed set of parameters for a channel","Transaction processing at committing peer side consists of validation (vscc) & commitment (performed by a transaction processor component). The token-related setup of the committing peer expands on both components.    *Acceptance*: I can setup the peer using a fixed set of fabtoken parameters, and monitor the internal state of the peer to ensure that FabToken initialisation took place with the right parameters.",Story,Medium,Closed,"2018-07-25 08:13:32","2018-07-25 08:13:32",2
"Hyperledger Fabric","As a token infrastructure developer, I want to create a serialized protocol buffer message that provides the parameters for a FabToken system","Acceptance: I can create a serialized protocol buffer message from a human readable YAML document that provides the FabToken initialization parameters. Validation is expected on the input such that inconsistent data is flagged.     ",Story,Medium,Closed,"2018-07-23 13:52:03","2018-07-23 13:52:03",2
"Hyperledger Fabric","As a fabric developer, I can explicitly enable token processing capabilities in the channel configuration","Capabilities are used to gate features and functions that impact a network of peers. We need to establish a capability name (and associated configuration support) to enable the token features of fabric.    Acceptance: I can define the new capability in an config update transaction, submit it, and observe the peer can support the new capability.         3 points",Story,Medium,Closed,"2018-07-23 13:45:05","2018-07-23 13:45:05",3
"Hyperledger Fabric","Add CORS support","Fabproxy needs CORS support to allow for requests other than locally.",Task,Medium,Closed,"2018-07-06 18:23:48","2018-07-06 18:23:48",1
"Hyperledger Fabric","Initial JSON RPC Calls","Fabproxy will implement getCode, call, sendTransaction,getTransactionReceipt, account. These API calls are the bare minimum to interact using the web3.js library.",Task,Medium,Closed,"2018-07-06 18:20:13","2018-07-06 18:20:13",4
"Hyperledger Fabric","As a peer org admin, I need a chaincode API to define a chaincode","This story corresponds to the 'Define' step in the design document from FAB-8787.    The implementation should add a new chaincode function called {{Define}} which accepts a new message as its only parameter.  This message should have a single field, corresponding to the {{Definition}} message as defined in FAB-10726.  It should return a new empty message.    It should read from the organizations private store the key at <hash> and verify that each the messages are equal or fail.  It should use protobuf equality checking rather than direct bytes comparison.    Next, it should check to see whether the world state key <chaincode_name> is set.  If so, it should should read the bytes there, unmarshal it as a chaincode definition, and check that the sequence contained in the new definition is exactly one larger than the existing sequence number or fail.  If the key does not exist, it should ensure that the sequence number is 0 or fail.    Finally, it should marshal the definition and store it at world state key <chaincode_name> and return the empty message successfully.",Story,Medium,Closed,"2018-06-19 21:58:08","2018-06-19 21:58:08",2
"Hyperledger Fabric","As a peer org admin, I need a chaincode API to signal my approval to execute a chaincode with certain parameters on a channel","This corresponds to the 'InstallChaincodeMetadata' step described in the FAB-8787 design document.    This chaincode API should be called {{AgreeToDefine}} and should accept as input a message containing a single field {{Definition}} which is itself a protobuf message with the fields:  # Name as a string  # Version as a string  # Sequence an unsigned 64 bit integer  # Hash as bytes (corresponding to the hash returned by FAB-10725)  # Endorsement plugin as string  # Validation plugin as string  # ValidationParameter as bytes    The chaincode API should return an empty protobuf message.    The function should first verify that the user is an administrator of the org per the channel configuration.  Then it should then take the {{Definition}} and put it in the organization's private data collection at key <hash>.    Note, the ability to write to an org scoped collection does not exist at the time of writing this story, but should be implemented via FAB-8864.",Story,Medium,Closed,"2018-06-19 21:49:31","2018-06-19 21:49:31",2
"Hyperledger Fabric","As a peer admin, I need a chaincode API to install ChaincodeInstallPackages.","The new lifecycle system chaincode needs to expose a function to allow the installation of ChaincodeInstallPackages.    It should take as a parameter a message containing the name, version, and ChaincodeInstallPackages.  It should return a message containing the hash of the code package.    The chaincode function name should be {{InstallCodePackage}}    Both the input and output should be new protobuf messages so that we may use the protobuf versioning mechanisms to extend and deprecate fields.    It should declare a new interface which declares the dependency on the function provided by FAB-10720 to store the package.",Story,Medium,Closed,"2018-06-19 21:34:09","2018-06-19 21:34:09",2
"Hyperledger Fabric","As a fabric developer, I need a way to retrieve the hash of a persisted ChaincodeInstallPackages by name/version.","FAB-10720 introduces a way to persist chaincode packages onto the filesystem and FAB-10723 introduces a way to retrieve those packages by hash.    However, users may not know the hash of their installed chaincode by may only know the friendlier name/version. In this case, we will need to be able to look up the hash by name/version. Once the correct hash is known, the existing API for retrieving the code bytes themselves may be used.    The implementation should accept name/version as parameters, and return a byte slice which is the hash.",Story,Medium,Closed,"2018-06-19 21:27:57","2018-06-19 21:27:57",1
"Hyperledger Fabric","As a fabric developer, I need a way to retrieve persisted ChaincodeInstallPackages by hash.","FAB-10720 introduces a way to persist the chaincode install packages.  In order for this to be useful, this persistence mechanism must also allow chaincodes to be retrieved.    The implementation should accept a package hash (corresponding to the hash of the marshaled chaincode install package) and retrieve the package itself, as well as the stored name and version associated with this package.",Story,Medium,Closed,"2018-06-19 21:23:14","2018-06-19 21:23:14",1
"Hyperledger Fabric","As a fabric developer, I need a way to persistently store ChaincodeInstallPackages.","As part of the new lifecycle work, there is a new chaincode package format as defined via FAB-10719.  In order for the new life cycle to use this new package format, it needs a way to persist these code packages.    The existing persistence is done through the ccprovider package, however, because of the legacy and problematic nature of this code (package scoped state and functions), and the irrelevant details like instantiation policy, extending the existing mechanisms is likely to be more work than simply creating a new persistence system.    This new persistence should take as a parameter a name, a version, and a set of bytes.  This set of bytes is a marshaled form of the the new message from FAB-10719.    The persistence should use the existing configurable chaincode storage directory to store chaincodes, but instead of storing them as '<name>.<version>' as the current code does, it should store the marshaled package and the package name/version as {{<hash_of_chaincode_install_package>.bin}} and {{<hash_of_chaincode_install_package>.json}} respectively.    The implementation should be careful not to expose these details to the user.    The implementer should evaluate whether creating a new file in the ccprovider package, or simply creating a new package is more sensible for this work.",Story,Medium,Closed,"2018-06-19 21:17:38","2018-06-19 21:17:38",2
"Hyperledger Fabric","As chaincode developer, I need a new message type to serialize chaincode install packages.","The new lifecycle work will need a way to store chaincode to the filesystem.  Today, the peer stores chaincode either in a CDSPackage or SignedCDSPackage, both of which are inappropriate for the new lifecycle.    These existing package formats include references to legacy datastructures that do not make sense in the new lifecycle world, such as instantiation policy, and conflate things which identify the chaincode (ie, its name, version, and hash) with properties of the chaincode itself (such as its type, and code).    This should be a new protobuf message named {{ChaincodeInstallPackage}}. which includes:   # {{Type}} as a string (ie, go, java, node)   # {{Path}} as a string (as required by some of the current platform packages)   # {{CodePackage}} the package itself as bytes (typically a tar file).",Story,Medium,Closed,"2018-06-19 21:09:18","2018-06-19 21:09:18",1
"Hyperledger Fabric","Usability: idemixgen user versus admin difference","It's not clear how you can tell that you are using an admin setup or a user setup after using the tool. The output all goes to a directory user. How do I know that the admin flag worked as expected?",Story,Medium,Closed,"2018-05-18 21:11:34","2018-05-18 21:11:34",1
"Hyperledger Fabric","Implement chaincode instantiate and upgrade","implement chain code deploy and upgrade",Story,Medium,Closed,"2017-12-18 12:54:01","2017-12-18 12:54:01",20
"Hyperledger Fabric","Add ability to execute on command line","The ability to execute openssl commands and use the output in the test will assist in the encryption testing.",Sub-task,Medium,Closed,"2017-10-16 19:35:54","2017-10-16 19:35:54",2
"Hyperledger Fabric","Build with Go 1.9 by default","The final step is moving to Go 1.9 is to actually build with Go 1.9.  In order to do this, we just need to move to a baseimage which uses Go 1.9",Sub-task,High,Closed,"2017-09-10 11:41:13","2017-09-10 11:41:13",1
"Hyperledger Fabric","Balance Transfer sample application using Fabric Java SDK","A *balance transfer* spring boot application using +fabric SDK java+ which will demonstrates all the basic _functionalities_ of *hyperledger 1.0*, such as enrolling and registering user , creating channel , installing chaincode , instantiating chaincode , invoking chaincode and querying chaincode. I have created this sample application for reference so that people who want to develop a hyperledger fabric solution using Java SDK can use the sample to accelerate their application development.",Story,High,Closed,"2017-08-30 05:49:19","2017-08-30 05:49:19",5
"Hyperledger Fabric","Reconfigure membership in examples.","How to conduct channel membership changes is a frequently asked question.    The tools are all there, and there is some fragmented documentation around this, but the best way to document is through example.    It should be relatively straghtforward to enhance one of the examples to define three application organizations instead of 2, then create a channel with two members, and add the third.    This is an exercise that I've gone though by hand and would be happy to walk the implementer through.",Story,Medium,Closed,"2017-08-21 16:57:56","2017-08-21 16:57:56",3
"Hyperledger Fabric","Clarify policy evaluation errors","The logs for policy evaluation can be quite unintuitive to the uninitiated.    This CR is to evaluate this logging and attempt to improve it to be less opaque.",Story,Medium,Closed,"2017-08-11 13:40:55","2017-08-11 13:40:55",2
"Hyperledger Fabric","As I fabric developer I want the SCCs to use the new ACLProvider to enforce access control","The new ACLProvider offers a centralised way to manage access control to resources on channels. The following SCCs will be updated to use it: QSCC, CSCC, LSCC, Endorsement (Proposal and CC2CC).",Sub-task,High,Closed,"2017-08-11 01:25:18","2017-08-11 01:25:18",2
"Hyperledger Fabric","Split configtx processing and channelconfig dependency.","The current configtx code was written under the assumption that it was managing a channel configuration.  Although there is some abstraction via the use of interfaces to make unit testing easier, it's not currently possible to use the configtx processing for something like the RSCC support.    This story is to remove the channel config specifics from the configtx package, and to factor the common components out of the channel config package into a common config package.",Story,Medium,Closed,"2017-08-07 17:57:52","2017-08-07 17:57:52",8
"Hyperledger Fabric","Set up Makefile to allow fabric to be a git submodule","We would like to include the fabric repository as a git submodule in our repository as a dependency. Ideally, we would be able to build the necessary images and executables that are needed from this submodule.     Currently, the Makefile makes some assumptions that the directory structure will be hyperledger/fabric/... The Makefile should be more flexible to allow for a different structure.",Sub-task,Medium,Closed,"2017-07-31 15:24:29","2017-07-31 15:24:29",1
"Hyperledger Fabric","Demonstrate Organization Unit usage wrt to policy settings","Show how to use the concept of Organization Units wrt to configuring policy.",Story,Medium,Closed,"2017-07-26 19:06:53","2017-07-26 19:06:53",13
"Hyperledger Fabric","Behave test framework does not handle uppercase and mixchars in chaincode names ","During deployment when behave tests are passed uppercase and mixchar names for chaincode names is tests fail.                 commit level:  Behave Fmwk: *d95525a64e7903565128d4c25ca522365ef6a926*  Fabric *b5c74cb8838d07f2101652a1c0acbb3b033a7660*{code}",Sub-task,Medium,Closed,"2017-07-18 16:02:03","2017-07-18 16:02:03",3
"Hyperledger Fabric","Move solo to optimized message flow",,Sub-task,Medium,Closed,"2017-07-11 19:20:24","2017-07-11 19:20:24",2
"Hyperledger Fabric","Remove filters from multichannel",,Sub-task,Medium,Closed,"2017-07-11 19:20:07","2017-07-11 19:20:07",2
"Hyperledger Fabric","Remove filter.Committer notion entirely",,Sub-task,Medium,Closed,"2017-07-11 19:19:49","2017-07-11 19:19:49",2
"Hyperledger Fabric","Remove filters from Broadcast path",,Sub-task,Medium,Closed,"2017-07-11 19:19:37","2017-07-11 19:19:37",2
"Hyperledger Fabric","Use MsgProcessor in Broadcast component",,Sub-task,Medium,Closed,"2017-07-11 19:19:26","2017-07-11 19:19:26",2
"Hyperledger Fabric","Replace the Enqueue method",,Sub-task,Medium,Closed,"2017-07-11 19:19:11","2017-07-11 19:19:11",2
"Hyperledger Fabric","Remove blockcutter message validation",,Sub-task,Medium,Closed,"2017-07-11 19:18:57","2017-07-11 19:18:57",2
"Hyperledger Fabric","Move interfaces from multichannel",,Sub-task,Medium,Closed,"2017-07-11 19:18:44","2017-07-11 19:18:44",2
"Hyperledger Fabric","Reorganize orderer dir",,Sub-task,Medium,Closed,"2017-07-11 19:18:28","2017-07-11 19:18:28",2
"Hyperledger Fabric","Remove committers from ProcessConfigMsg",,Sub-task,Medium,Closed,"2017-07-11 19:18:05","2017-07-11 19:18:05",2
"Hyperledger Fabric","Remove committers from the blockcutter path",,Sub-task,Medium,Closed,"2017-07-11 19:17:38","2017-07-11 19:17:38",2
"Hyperledger Fabric","Optimize orderer message processing flow to remove redundant checks","The current orderer works in a two pass message filtering architecture.  The initial pass is done when the client invokes {{Broadcast}} and verifies that the message might be valid once ordered, then sends to the consenter for ordering.  After ordering, the consenter re-runs the verification on the messages as a second pass. This second pass ensures that the message is still valid, even after the other in-flight messages have committed.    The only cause of a message validating at {{Broadcast}} but not validating after ordering is if the channel configuration changes.  For instance, the max message size might be reduced, a certificate might be revoked, etc.    The problem with this architecture is that it implies that in the Kafka case, all messages are processed {{n+1}} times, where {{n}} is the number of OSNs.  In the Solo case, this implies messages are processed {{2}} times (as {{n}} is fixed to {{1}}.  However, in the green path, it should only be necessary to process the message {{1}} time.    The message verification step is the primary CPU bound (as it involves hashing and checking signatures) for the orderer, so improving from {{n+1}} to {{1}} has the potential to double or more the performance of the orderer.    To achieve this change, the orderer common components must be noticeably restructured.  The {{Broadcast}} path needs to include the config sequence at which the message was validated when pushing to consenus.  Then, the consenter needs to track changes in the config sequence number, trigger the second pass revalidation only when needed.  The message validation is currently buried within filters and filters within blockcutter, so this will need to be factored out into its own message processing package.    This is also a good opportunity to fix some of the directory structure which has accumulated considerable cruft during the v1 development.    Will add architectural diagrams.",Story,High,Closed,"2017-07-11 18:49:21","2017-07-11 18:49:21",13
"Hyperledger Fabric","Add orderer performance tests","Today, all of our performance testing for the orderer is being done by spinning up an orderer process, bound to a port, then having external clients direct traffic to the ordering service.    This has been fine to get an overall impression of performance with the ordering code, but it's very time consuming and difficult to gauge the effect of performance improvements and to catch performance regressions.    Completion of this story should require the following:   # Refactor {{main.go}} so that the server can be started without binding to a real address, and instead supply a mock structure to register the gRPC services with.   # Create mock {{Broadcast}} clients which will submit properly signed messages via the {{Broadcast}} API. The number of clients should be arbitrary, and the message sizes should also be configurable, as should the desired channel.   # Create mock {{Deliver}} clients which operate similarly to the {{Broadcast}} ones.   # Create performance tests that leverage 1-3 to cover a variety of scenarios. Some which immediately come to mind:   ** 1 Broadcast and 1 Deliver, each going as fast as possible on a single channel   ** many Broadcast and 1 Deliver on a single channel   ** many Broadcast and many Deliver on a single channel   ** 1 Broadcast and 1 Deliver for each of many channels   ** many Broadcast and many Deliver for each of many channels   ** (a)-(e) each with small, medium, and large messages",Story,High,Closed,"2017-07-10 18:02:54","2017-07-10 18:02:54",8
"Hyperledger Fabric","peer/ccenv should not include the shim","In the past, we made the decision to include the shim both as a convenience to our users (to avoid explicit vendoring) and as a space optimization (why have every chaincode include the same shim lib over and over?).    Fast forward to now: go dependency management leaves much to be desired.  Having the ccenv include the shim can be problematic w.r.t. fragility between the included shim and the chaincode application.  For example, try to write an application which uses the timestamp features of the shim and you will receive errors due to conflicts between the fabric vendored version of the protobuf library and the chaincode application.    Now that we have auto-vendoring, the convenience factor for including the shim is gone.  It only leaves the space optimization consideration.  Considering how fragile go dependency management is, we may want to go the conservative route and simply remove all dependencies from the ccenv and make peer package / chaintool package provide them via the auto-vendor feature.         If we are going to do this, we should do it before v1.0 is cut so that chaincode apps for 1.0 are properly formed in a non-breaking way going forward.",Story,Medium,Closed,"2017-07-05 03:44:41","2017-07-05 03:44:41",3
"Hyperledger Fabric","behave test fmwk: could we check for existence of sub_elements in return data set","Like being able to verify for an element from returned json structue:    Like for instance marble has dataset like: \{name, color, size, owner}:\{marble1,red,35,tom} when using marbles02 chaincode.    If i would like verify say owner of marble1, then may be I would have the following in my feature file     ",Sub-task,Medium,Closed,"2017-06-23 20:34:31","2017-06-23 20:34:31",2
"Hyperledger Fabric","Refactor the docker composition files for the test network topologies","Currently, each network topology is defined in its own single file. It would prove useful for maintaining and reading if there were a single base component file that each network setup can use when setting up Fabric networks for system tests.",Sub-task,Medium,Closed,"2017-06-13 16:52:35","2017-06-13 16:52:35",2
"Hyperledger Fabric","add missing license headers to fabric-test-resources","add missing license headers to fabric-test-resources",Sub-task,Medium,Closed,"2017-06-12 19:38:05","2017-06-12 19:38:05",1
"Hyperledger Fabric","address missing license headers fabric","address missing license headers fabric",Sub-task,High,Closed,"2017-06-12 18:32:26","2017-06-12 18:32:26",1
"Hyperledger Fabric","address missing license headers fabric-baseimage","address missing license headers fabric-baseimage",Sub-task,High,Closed,"2017-06-12 18:32:11","2017-06-12 18:32:11",1
"Hyperledger Fabric","address missing license headers fabric-sdk-java","address missing license headers fabric-sdk-java",Sub-task,High,Closed,"2017-06-12 18:31:55","2017-06-12 18:31:55",1
"Hyperledger Fabric","address missing license headers fabric-sdk-node","address missing license headers fabric-sdk-node",Sub-task,High,Closed,"2017-06-12 18:31:38","2017-06-12 18:31:38",1
"Hyperledger Fabric","address missing license headers fabric-ca","address missing license headers fabric-ca",Sub-task,High,Closed,"2017-06-12 18:31:16","2017-06-12 18:31:16",1
"Hyperledger Fabric","address missing licenses fabric-chaintool","address missing licenses fabric-chaintool",Sub-task,High,Closed,"2017-06-12 18:30:51","2017-06-12 18:30:51",1
"Hyperledger Fabric","create v1.0.0-beta release notes for fabric-sdk-java","create release notes that generalize the changes since v1.0.0-alpha2",Sub-task,Medium,Closed,"2017-06-05 20:14:14","2017-06-05 20:14:14",1
"Hyperledger Fabric","create v1.0.0-beta release notes for fabric-sdk-node","create release notes for v1.0.0-beta that generalize changes since v1.0.0-alpha2    generate changelog",Sub-task,Medium,Closed,"2017-06-05 20:14:14","2017-06-05 20:14:14",1
"Hyperledger Fabric","create release notes for fabric-ca","create release notes that generalize the changes since alpha2 to be used in release tag",Sub-task,Medium,Closed,"2017-06-05 20:14:13","2017-06-05 20:14:13",1
"Hyperledger Fabric","create release notes text for fabric","create release notes for fabric text that generalize the nature of changes since v1.0.0-alpha2",Sub-task,Medium,Closed,"2017-06-05 20:14:13","2017-06-05 20:14:13",1
"Hyperledger Fabric","tag v1.0.0-beta release of fabric-sdk-java","NOTE: Tag release with the release_notes/v1.0.0-beta.md as the tag comment         % git tag \-a v1.0.0-beta \-F release_notes/v1.0.0-beta.md         tag release with a commit message that includes:    release notes    known vulnerabilities    other known issues    changelog link",Sub-task,Medium,Closed,"2017-06-05 20:14:13","2017-06-05 20:14:13",1
"Hyperledger Fabric","tag v1.0.0-beta for fabric-sdk-node","NOTE: Tag release with the release_notes/v1.0.0-beta.md as the tag comment         % git tag \-a v1.0.0-beta \-F release_notes/v1.0.0-beta.md         tag release with a commit message that includes:    release notes    known vulnerabilities    other known issues    changelog link    create change log      ",Sub-task,Medium,Closed,"2017-06-05 20:14:13","2017-06-05 20:14:13",1
"Hyperledger Fabric","publish v1.0.0-beta java sdk",,Sub-task,Medium,Closed,"2017-06-05 20:14:12","2017-06-05 20:14:12",1
"Hyperledger Fabric","publish v1.0.0-beta release node sdk","See instructions in FAB-2802.    these will trigger CI to publish to npm:  fabric-client/package.json: version=1.0.0-beta  fabric-ca-client/package.json: version=1.0.0-beta    examples/balance-transfer update to target 1.0.0-beta artifacts for docker images, and fabric-client and fabric-ca-client npm",Sub-task,Medium,Closed,"2017-06-05 20:14:12","2017-06-05 20:14:12",1
"Hyperledger Fabric","tag v1.0.0-beta release of fabric-ca","     NOTE: Tag release with the release_notes/v1.0.0-beta.md as the tag comment         % git tag \-a v1.0.0-beta \-F release_notes/v1.0.0-beta.md         tag release with a commit message that includes:    release notes    known vulnerabilities    other known issues    changelog link    create change log",Sub-task,Medium,Closed,"2017-06-05 20:14:12","2017-06-05 20:14:12",1
"Hyperledger Fabric","tag v1.0.0-beta release of fabric","NOTE: Tag release with the release_notes/v1.0.0-beta.md as the tag comment         % git tag \-a v1.0.0-beta \-F release_notes/v1.0.0-beta.md         tag release with a commit message that includes:    release notes    known vulnerabilities    other known issues    changelog link",Sub-task,Medium,Closed,"2017-06-05 20:14:12","2017-06-05 20:14:12",1
"Hyperledger Fabric","update Getting Started link to resolve to v1.0.0-beta bootstrap.sh","create shortened URL that resolves to v1.0.0-rc1 tagged version of bootstrap script    scripts/bootstrap-v1.0.0-rc1.sh",Sub-task,Medium,Closed,"2017-06-05 20:14:11","2017-06-05 20:14:11",1
"Hyperledger Fabric","prepare Makefile for v1.0.0-rc1","BASE_VERSION = 1.0.0-rc1   PREV_VERSION = 1.0.0-beta   IS_RELEASE = false",Sub-task,Medium,Closed,"2017-06-05 20:14:11","2017-06-05 20:14:11",1
"Hyperledger Fabric","prepare Makefile for v1.0.0-rc1","PROJECT_NAME = fabric-ca   BASE_VERSION = 1.0.0-rc1   IS_RELEASE = false",Sub-task,Medium,Closed,"2017-06-05 20:14:11","2017-06-05 20:14:11",1
"Hyperledger Fabric","prepare Makefile for v1.0.0-beta release","BASE_VERSION = 1.0.0-beta   IS_RELEASE = true     generate changelog",Sub-task,Medium,Closed,"2017-06-05 20:14:11","2017-06-05 20:14:11",1
"Hyperledger Fabric","prepare Makefile for v1.0.0-beta release","BASE_VERSION = 1.0.0-beta   PREV_VERSION = 1.0.0-alpha2   IS_RELEASE = true    docs/source/releases.rst should be updated with prose and link to release page    change log should be generated and linked from docs/source/releases.rst",Sub-task,Medium,Closed,"2017-06-05 20:14:11","2017-06-05 20:14:11",1
"Hyperledger Fabric","Cut v1.0.0-beta release","Prepare and publish v1.0.0-beta release of Hyperledger Fabric          Some related discussions also took place [here|https://docs.google.com/document/d/1mPTMjXG_b-mgZd2_EUN9W-82ez0PrWoxIiPgcAAABwE/edit#heading=h.7ylvqvqpim4]. ",Task,High,Closed,"2017-06-05 20:14:08","2017-06-05 20:14:08",2
"Hyperledger Fabric","create scheme to handle version-specific bootstrap.sh","we need an ability to have version-specific bootstrap.sh",Sub-task,Medium,Closed,"2017-06-02 14:07:47","2017-06-02 14:07:47",1
"Hyperledger Fabric","create v1.0.0-alpha3 release notes for fabric-sdk-java","create release notes that generalize the changes since v1.0.0-alpha2",Sub-task,Medium,Closed,"2017-05-30 16:36:09","2017-05-30 16:36:09",1
"Hyperledger Fabric","create v1.0.0-alpha3 release notes for fabric-sdk-node","create release notes for v1.0.0-beta that generalize changes since v1.0.0-alpha2",Sub-task,Medium,Closed,"2017-05-30 16:34:28","2017-05-30 16:34:28",1
"Hyperledger Fabric","create release notes for fabric-ca","create release notes that generalize the changes since alpha2 to be used in release tag",Sub-task,Medium,Closed,"2017-05-30 16:32:14","2017-05-30 16:32:14",1
"Hyperledger Fabric","create release notes text for fabric","create release notes for fabric text that generalize the nature of changes since v1.0.0-alpha2",Sub-task,Medium,Closed,"2017-05-30 16:30:02","2017-05-30 16:30:02",1
"Hyperledger Fabric","tag v1.0.0-alpha3 release of fabric-sdk-java","tag release with a commit message that includes:    release notes    known vulnerabilities    other known issues    changelog link",Sub-task,Medium,Closed,"2017-05-30 16:15:39","2017-05-30 16:15:39",1
"Hyperledger Fabric","tag v1.0.0-alpha3 for fabric-sdk-node","tag release with a commit message that includes:    release notes    known vulnerabilities    other known issues    changelog link    create change log      ",Sub-task,Medium,Closed,"2017-05-30 16:14:42","2017-05-30 16:14:42",1
"Hyperledger Fabric","publish v1.0.0-alpha3 java sdk",,Sub-task,Medium,Closed,"2017-05-30 15:47:01","2017-05-30 15:47:01",1
"Hyperledger Fabric","publish v1.0.0-alpha3 release node sdk",,Sub-task,Medium,Closed,"2017-05-30 15:46:17","2017-05-30 15:46:17",1
"Hyperledger Fabric","tag v1.0.0-alpha3 release of fabric-ca","tag release with a commit message that includes:    release notes    known vulnerabilities    other known issues    changelog link    create change log",Sub-task,Medium,Closed,"2017-05-30 15:44:12","2017-05-30 15:44:12",1
"Hyperledger Fabric","tag v1.0.0-alpha3 release of fabric","tag release with a commit message that includes:    release notes    known vulnerabilities    other known issues    changelog link",Sub-task,Medium,Closed,"2017-05-30 15:42:09","2017-05-30 15:42:09",1
"Hyperledger Fabric","update Getting Started link to resolve to v1.0.0-alpha3 bootstrap.sh","create shortened URL that resolves to v1.0.0-beta tagged version of bootstrap.sh",Sub-task,Medium,Closed,"2017-05-30 15:40:48","2017-05-30 15:40:48",1
"Hyperledger Fabric","prepare Makefile for v1.0.0-beta","BASE_VERSION = 1.0.0-beta   PREV_VERSION = 1.0.0-alpha3   IS_RELEASE = false",Sub-task,Medium,Closed,"2017-05-30 15:25:36","2017-05-30 15:25:36",1
"Hyperledger Fabric","prepare Makefile for v1.0.0-beta","PROJECT_NAME = fabric-ca   BASE_VERSION = 1.0.0-beta   IS_RELEASE = false",Sub-task,Medium,Closed,"2017-05-30 15:17:48","2017-05-30 15:17:48",1
"Hyperledger Fabric","prepare Makefile for v1.0.0-alpha3 release","BASE_VERSION = 1.0.0-alpha3   IS_RELEASE = true     ",Sub-task,Medium,Closed,"2017-05-30 15:15:33","2017-05-30 15:15:33",1
"Hyperledger Fabric","prepare Makefile for v1.0.0-alpha3 release","BASE_VERSION = 1.0.0-alpha3   PREV_VERSION = 1.0.0-alpha2   IS_RELEASE = true    docs/source/releases.rst should be updated with prose and link to release page    change log should be generated and linked from docs/source/releases.rst",Sub-task,Medium,Closed,"2017-05-30 15:14:01","2017-05-30 15:14:01",1
"Hyperledger Fabric","Cut v1.0.0-alpha3 release","Prepare and publish v1.0.0-alpha3 release of Hyperledger Fabric          Some related discussions also took place [here|https://docs.google.com/document/d/1mPTMjXG_b-mgZd2_EUN9W-82ez0PrWoxIiPgcAAABwE/edit#heading=h.7ylvqvqpim4]. ",Task,High,Closed,"2017-05-30 14:47:58","2017-05-30 14:47:58",2
"Hyperledger Fabric","Vendor gorilla/mux REST library",,Sub-task,Medium,Closed,"2017-05-26 02:01:05","2017-05-26 02:01:05",1
"Hyperledger Fabric","Add REST server component to expose proto translator","This task is for introducing the server which will listen for api requests as discussed in the parent issue.",Sub-task,Medium,Closed,"2017-05-22 22:50:07","2017-05-22 22:50:07",3
"Hyperledger Fabric","Create config update computation component","This task is for creating the code necessary to take in two config messages, and compute the corresponding config update message.",Sub-task,Medium,Closed,"2017-05-22 22:48:47","2017-05-22 22:48:47",3
"Hyperledger Fabric","Add proto translator method extensions to fabric proto messages","With the proto translator and component pieces in place, the actual fabric messages which it is to translate must be annotated with the necessary methods to be translated.",Sub-task,Medium,Closed,"2017-05-22 22:47:20","2017-05-22 22:47:20",1
"Hyperledger Fabric","Create proto translator for dynamic field components","Some proto fields have component messages whose behavior is determined by some other context, such as where they appear relative to other messages.  These messages cannot be simply annotated like other the statically or variably opaque messages, but must instead be decorated at runtime with their descriptive attributes.  This task is for creating the component which handles these dynamic fields.",Sub-task,Medium,Closed,"2017-05-22 22:46:11","2017-05-22 22:46:11",1
"Hyperledger Fabric","Create proto translator for variably opaque field component","Some proto fields are marshaled proto messages who's type varies based on the other contents of the message (possibly including other statically marshaled fields).  This task if for creating the variably opaque field component.",Sub-task,Medium,Closed,"2017-05-22 22:44:10","2017-05-22 22:44:10",1
"Hyperledger Fabric","Create proto translator for statically opaque field component","Some proto fields are simply statically marshaled fields, namely their type is known at compile time.  This task is to handle the creation of the component to handle these.",Sub-task,Medium,Closed,"2017-05-22 22:43:10","2017-05-22 22:43:10",1
"Hyperledger Fabric","Create proto translator nested field component","Proto messages embedded inside of other proto messages must be passed back through the common translator component.  This component should act as a catch-all for otherwise unhandled proto messages.",Sub-task,Medium,Closed,"2017-05-22 22:42:24","2017-05-22 22:42:24",1
"Hyperledger Fabric","Create proto translator component framework","Doing bidirectional proto translation to/from deep JSON requires a significant amount of dynamic programming.  Having each message try to handle this work independently is a recipe for disaster, so the bulk of the reflection work needs to be centralized so that protos may be simply extended with methods which drive the proto translation framework.    This task is to cover designing and implementing this plug-able core reflection framework.",Sub-task,Medium,Closed,"2017-05-22 22:41:15","2017-05-22 22:41:15",3
"Hyperledger Fabric","Provide various governance options for scenarios.","Provide governance options of Dictatorial/Democratic/Unanimous as scenario options for controlling the default policy settings.",Task,Medium,Closed,"2017-05-17 16:11:15","2017-05-17 16:11:15",1
"Hyperledger Fabric","Support subset selection of consortium members for channel creation","Provide support for channel creators to choose a subset of the consortium members for channel membership.",Task,Medium,Closed,"2017-05-17 16:08:37","2017-05-17 16:08:37",1
"Hyperledger Fabric","cut v1.0.0-alpha2 release ","prepare for the alpha2 release process. -This will involve creating the release branch as per the process proposal proposed by Dave at the Hackfest.-     -Suggest that we leave master as master and actually create a develop branch after we tag the v1.0.0-alpha2 release on the master branch, and that we then shift the target of all CRs to the develop branch from that point forward. Master will only merge FF merges from a temporary release branch created from develop which will run through the gauntlet of tests before being merged to master and cutting a release.-    -Note that this will also require that all in-flight CRs be resubmitted against the develop branch.-    just tag and publish release without changing branch structure for now.",Task,Highest,Closed,"2017-05-12 12:26:55","2017-05-12 12:26:55",1
"Hyperledger Fabric","Increase test coverage for common/config",,Task,High,Closed,"2017-05-12 11:00:23","2017-05-12 11:00:23",1
"Hyperledger Fabric","Placeholder for behave tests ","We have to create templates of the tests that will be executed using the behave framework. The Scenario name should look as follows:         Each scenario should be tagged with the @skip tag. This tag will be removed once the test is written and ready for use.     ",Story,Medium,Closed,"2017-05-11 15:38:24","2017-05-11 15:38:24",3
"Hyperledger Fabric","Create a description of why blockchain","Would like to build the story from the very high level down to the details of Hyperledger Fabric. This is the first phase, description of the very high level components of blockchain. Ultimately would like to move to the over arching Hyperledger project umbrella, then each project can build off of it. But wanted to start the story here, so for now will host within fabric doc.",Task,High,Closed,"2017-05-10 21:58:51","2017-05-10 21:58:51",1
"Hyperledger Fabric","need security vulnerability reporting process implemented and documented","We need a documented process for submitting security issues relating to Fabric implemented and documented to satisfy the CII Badge requirements.",Sub-task,High,Closed,"2017-05-10 16:47:06","2017-05-10 16:47:06",1
"Hyperledger Fabric","A document that will outline considerations when starting a network","This is a document that will have a lot of cross with best practices. Considerations and thoughts that need to happen when creating a new network. Starter list of items:    -  Who will define membership in the network, and how?  -  Where will my network be hosted?  -  What are the features I'll need?  -  What are the technical specifications I’ll need to make it work?  -  What kinds of special application layers will I need?    regarding    -  Governance - Fab-2308  -  :ref:`Membership-Services`  -  :ref:`Ordering-Service`  -  :ref:`Ledger` for database configuration - Fab-2308  -  Security Options  -  :ref:`SDK` s/APIs  -  :ref:`Assets`  -  :ref:`Channel` benefits",Epic,Medium,Closed,"2017-05-10 14:58:42","2017-05-10 14:58:42",8
"Hyperledger Fabric","Add container start/stop functionality","The tests should have the capability to start and stop containers.    [https://gerrit.hyperledger.org/r/#/c/9667]     ",Sub-task,Highest,Closed,"2017-05-09 19:35:56","2017-05-09 19:35:56",2
"Hyperledger Fabric","Add endorser_util","This should contain the code needed to perform the key endorser functionality such as   * install   * instantiate   * create channel   * join channel   * invoke chaincode   * query chaincode",Sub-task,Medium,Closed,"2017-05-09 17:38:00","2017-05-09 17:38:00",3
"Hyperledger Fabric","Add a Readme for the system feature tests","A readme that contains at least the following should be added to the test/feature directory:   * Getting Started   * Prereqs   * How to contribute       https://gerrit.hyperledger.org/r/#/c/9131/",Sub-task,Medium,Closed,"2017-05-09 17:11:06","2017-05-09 17:11:06",2
"Hyperledger Fabric","obtain CII badge","obtain a CII Badge from LF",Task,Medium,Closed,"2017-05-09 01:29:22","2017-05-09 01:29:22",1
"Hyperledger Fabric","Generate changelog for v1.0.0-alpha2","generate changelog for v1.0.0-alpha2",Task,High,Closed,"2017-05-08 23:21:14","2017-05-08 23:21:14",1
"Hyperledger Fabric","add license check script to fabric repo","see FAB-3674 for description",Task,Medium,Closed,"2017-05-05 13:21:05","2017-05-05 13:21:05",1
"Hyperledger Fabric","As a member of a network who runs a peer, I want to be able to support clients who transact with the network with a limited scope of permissions","Currently, access control is scoped by organization at the channel level. This means that clients / peers are interchangeable in many cases.    The desire here is to limit the scope of what clients who transact can actually do.   Examples include:    1) Request endorsements and query chaincode   2) Submit transactions to the orderer   3) No access to gossip network   4) No access to blocks only to their transactions   5) Related to 4 - events payload should be limited to transaction IDs if that is what is used to asynchronously learn the status of their transaction         The original intent was to introduce the concept of client orgs    A design doc is at https://docs.google.com/document/d/1oaR7IlpNCV6udvLhDootRtoruEvOrxByYVN4BQ___0A",Story,High,Closed,"2017-05-03 15:18:29","2017-05-03 15:18:29",4
"Hyperledger Fabric","Add composition calls for system tests",,Sub-task,Medium,Closed,"2017-05-01 03:13:38","2017-05-01 03:13:38",3
"Hyperledger Fabric","Modify comm implementation is use callback function to get secure dial options","The current gossip implementation is initialized with a set of dial options which don't change during the lifecycle of the peer.  In order to always get the most up to date secure dial options (which basically means dial options with the latest set of trusted roots for remote peers / organizations) this task will add a callback function to the comm impl",Sub-task,High,Closed,"2017-04-30 12:27:25","2017-04-30 12:27:25",1
"Hyperledger Fabric","Behave peer scaffolding","This scaffolding will be the basis for implementing the peer feature files.  ",Sub-task,Medium,Closed,"2017-04-28 20:18:05","2017-04-28 20:18:05",3
"Hyperledger Fabric","Serviceability - Operational Metrics for Fabric runtime components","When Fabric runtime components are deployed in real-world environments, it will be necessary to provide runtime metrics so that operators can actively monitor the health and status of each component.    Additionally, operators will need a way to integrate these operational metrics into their existing monitoring solutions and/or ask for recommendations for which tools to use.",Epic,Highest,Closed,"2017-04-25 13:07:45","2017-04-25 13:07:45",4
"Hyperledger Fabric","Provide a sample deployment and topology for Kubernetes","Kubernetes is a very popular Docker / container orchestration tool used by many cloud providers as well as by a growing number of companies as well.    Users would like to be able to quickly mimic a real world setup and have sample topologies, deployment scripts and documentation to create more realistic sandbox and production environments",Sub-task,Highest,"To Do","2017-04-22 11:54:33","2017-04-22 11:54:33",2
"Hyperledger Fabric","Provide a sample deployment and topology for Docker Swarm Mode","Docker 1.13+ has a built-in multi-host orchestration engine called Swarm Mode    This task is to provide the relevant artifacts and documentation to help create a sandbox topology using Docker Swarm",Sub-task,High,Closed,"2017-04-22 11:52:32","2017-04-22 11:52:32",2
"Hyperledger Fabric","As a Fabric user, I'd like to be able to set up real world deployment topologies","The current getting started is focused on using Docker Compose on a local machine or single remote node.  While this is great for testing and development of chaincode and applications, it does not mimic real world multi-host deployments.    Users would like to be able to quickly mimic a real world setup and have sample topologies, deployment scripts and documentation to create more realistic sandbox environments.",Story,High,Closed,"2017-04-22 11:49:40","2017-04-22 11:49:40",4
"Hyperledger Fabric","Add orderer test scaffolding","This scaffolding will be the basis for implementing the orderer feature files.",Sub-task,Medium,Closed,"2017-04-20 23:26:41","2017-04-20 23:26:41",3
"Hyperledger Fabric","Import protobuf files from bddtests directory","Instead of regenerating the python files based on the protobuf files, import the generating files for use in the utilities for these tests.",Sub-task,Medium,Closed,"2017-04-20 20:31:49","2017-04-20 20:31:49",3
"Hyperledger Fabric","Add Config utility for Behave functional tests","This config utility will contain functions that will be used when configuring a fabric network for use in the behave functional test runs. ",Sub-task,Medium,Closed,"2017-04-19 21:56:59","2017-04-19 21:56:59",3
"Hyperledger Fabric","Improve test coverage for github.com/hyperledger/fabric/core/comm package","The current coverage for the package is 62.8% but the major gap in tests for functions found in connection.go ",Task,Highest,Closed,"2017-04-13 12:54:33","2017-04-13 12:54:33",1
"Hyperledger Fabric","Include install script with each release package","As we currently distribute the various runtime components as Docker images, it is convenient to include a script which will download the correct version of the images for a given release and platform.    With this task, we'll include a script which will pull all of the images for a given release",Sub-task,High,Closed,"2017-04-13 11:02:33","2017-04-13 11:02:33",1
"Hyperledger Fabric","Remove sfhackfest from examples","The sfhackfest example is not longer relevant to the master branch / v1.0.0",Task,High,Closed,"2017-04-12 19:14:18","2017-04-12 19:14:18",1
"Hyperledger Fabric","Add release targets to Makefile","While there are targets to make binaries for some packages, we need a more uniform way of creating the binaries we want to publish.    We currently have 3 build platforms -  linux-amd64, ppc64le and s390x - but we don't have build environments for windows-amd64 or darwin-amd64 (macos).  Go has the ability to cross-compile so we'll add release targets for all platforms and can choose to cross-compile for Windows / macos in the CI for linux-amd64",Sub-task,Highest,Closed,"2017-04-12 16:46:34","2017-04-12 16:46:34",1
"Hyperledger Fabric","As a user of Fabric, I should be able to d/l platform specific binaries for all tools","As a user of Fabric, I should be able to d/l platform specific binaries for all tools including configtxgen fabric-chaintool, and fabric-ca (client) and any others that we currently require users to build from source.",Story,Highest,Closed,"2017-04-02 17:03:33","2017-04-02 17:03:33",4
"Hyperledger Fabric","Print read set, write set, delta set on inspection",,Sub-task,Medium,Closed,"2017-03-17 17:57:27","2017-03-17 17:57:27",1
"Hyperledger Fabric","Enable configtxgen for config updates",,Story,Medium,Closed,"2017-03-17 15:05:48","2017-03-17 15:05:48",13
"Hyperledger Fabric","Update default batch timeout to 2s",,Story,Medium,Closed,"2017-03-17 14:57:28","2017-03-17 14:57:28",1
"Hyperledger Fabric","Kafka integration into BDD","Kafka integration into BDD with [~<USER>.",Story,Medium,Closed,"2017-03-15 20:52:52","2017-03-15 20:52:52",1
"Hyperledger Fabric","Allow configtxgen to specify admin principal type",,Sub-task,Medium,Closed,"2017-03-14 19:05:19","2017-03-14 19:05:19",1
"Hyperledger Fabric","Lock down channel creation by consortium",,Story,Medium,Closed,"2017-03-13 21:14:49","2017-03-13 21:14:49",8
"Hyperledger Fabric","Cleanup common config mocks",,Story,Medium,Closed,"2017-03-10 18:35:20","2017-03-10 18:35:20",1
"Hyperledger Fabric","Document the configtx",,Story,Medium,Closed,"2017-03-10 16:07:16","2017-03-10 16:07:16",2
"Hyperledger Fabric","Remove old deprecated ChainCreationPolicies reference.",,Sub-task,Medium,Closed,"2017-03-10 04:11:22","2017-03-10 04:11:22",1
"Hyperledger Fabric","Expose committed config envelope",,Sub-task,Medium,Closed,"2017-03-08 20:26:24","2017-03-08 20:26:24",1
"Hyperledger Fabric","Include the consortium name for a channel in the channel config",,Sub-task,Medium,Closed,"2017-03-08 19:06:22","2017-03-08 19:06:22",1
"Hyperledger Fabric","Improve test coverage in github.com/hyperledger/fabric/common/config",,Story,Medium,Closed,"2017-03-08 18:14:53","2017-03-08 18:14:53",1
"Hyperledger Fabric","Set the default ModPolicy to Admins",,Sub-task,Medium,Closed,"2017-03-07 18:55:23","2017-03-07 18:55:23",1
"Hyperledger Fabric","Document fabric policies usage/creation",,Story,Medium,Closed,"2017-03-06 20:26:49","2017-03-06 20:26:49",1
"Hyperledger Fabric","Create channel tracking structures in consortium",,Sub-task,Medium,Closed,"2017-03-06 14:50:09","2017-03-06 14:50:09",1
"Hyperledger Fabric","Populate consortium config structures in configtxgen",,Sub-task,Medium,Closed,"2017-03-05 20:49:46","2017-03-05 20:49:46",1
"Hyperledger Fabric","Create consortium configuration structures",,Sub-task,Medium,Closed,"2017-03-05 19:39:07","2017-03-05 19:39:07",1
"Hyperledger Fabric","Expose created channels via ordering system channel configtx",,Story,Medium,Closed,"2017-03-05 19:37:25","2017-03-05 19:37:25",5
"Hyperledger Fabric","Enhance configtxgen inspection to include policies",,Sub-task,Medium,Closed,"2017-03-04 17:09:00","2017-03-04 17:09:00",1
"Hyperledger Fabric","Remove references to IngressPolicyNames and EgressPolicyNames",,Sub-task,Medium,Closed,"2017-03-03 00:52:33","2017-03-03 00:52:33",1
"Hyperledger Fabric","Enabled configtxgen to print configtx as JSON",,Sub-task,Medium,Closed,"2017-03-02 22:13:20","2017-03-02 22:13:20",1
"Hyperledger Fabric","Allow parsing of config outside of the configtx.Manager",,Sub-task,Medium,Closed,"2017-03-01 19:52:48","2017-03-01 19:52:48",1
"Hyperledger Fabric","Have configtx manager track deserialized values",,Sub-task,Medium,Closed,"2017-03-01 00:44:11","2017-03-01 00:44:11",1
"Hyperledger Fabric","Allow concurrent config proposals",,Sub-task,Medium,Closed,"2017-02-28 21:47:25","2017-02-28 21:47:25",1
"Hyperledger Fabric","Consolidate config components to single directory",,Sub-task,Medium,Closed,"2017-02-28 04:01:10","2017-02-28 04:01:10",1
"Hyperledger Fabric","Make config sequence explicit, and all config updates sequential",,Sub-task,Medium,Closed,"2017-02-27 21:32:54","2017-02-27 21:32:54",3
"Hyperledger Fabric","Move application config to common Proposer",,Sub-task,Medium,Closed,"2017-02-24 21:50:54","2017-02-24 21:50:54",1
"Hyperledger Fabric","Fix gossip proto style","The gossip protos were moved under fabric/protos after the fabric/protos were restyled to conform to proto style guidelines.  The gossip protos need to be brought in line with this.",Story,Medium,Closed,"2017-02-24 18:09:25","2017-02-24 18:09:25",1
"Hyperledger Fabric","Remove unnecessary header messages from configtx messages","After an audit with Elli, it's been concluded that the ChannelHeader embedded in the configtx.proto Config and ConfigUpdate messages are unnecessary, that the only piece of information needed is the ChannelId.    By removing these, the messages will be simpler to construct and understand.",Story,Medium,Closed,"2017-02-24 17:02:47","2017-02-24 17:02:47",1
"Hyperledger Fabric","Add generic proto intializer for Proposer framework",,Sub-task,Medium,Closed,"2017-02-23 18:53:16","2017-02-23 18:53:16",2
"Hyperledger Fabric","Encode anchor peers from configtx.yaml",,Sub-task,Medium,Closed,"2017-02-22 17:17:09","2017-02-22 17:17:09",1
"Hyperledger Fabric","Add block validation policy to config",,Story,Medium,Closed,"2017-02-21 16:59:15","2017-02-21 16:59:15",1
"Hyperledger Fabric","Move organization config onto common Proposer",,Sub-task,Medium,Closed,"2017-02-21 04:19:15","2017-02-21 04:19:15",1
"Hyperledger Fabric","Move orderer config to shared handler root",,Sub-task,Medium,Closed,"2017-02-21 03:30:12","2017-02-21 03:30:12",1
"Hyperledger Fabric","Create common config value handler root",,Sub-task,Medium,Closed,"2017-02-20 20:21:07","2017-02-20 20:21:07",2
"Hyperledger Fabric","Migrate channel creation onto configupdate common path",,Sub-task,Medium,Closed,"2017-02-19 21:36:02","2017-02-19 21:36:02",2
"Hyperledger Fabric","Create common config update codepath",,Sub-task,Medium,Closed,"2017-02-19 18:06:41","2017-02-19 18:06:41",2
"Hyperledger Fabric","Modify configtx ingress to require CONFIG_UPDATE",,Sub-task,Medium,Closed,"2017-02-18 06:38:18","2017-02-18 06:38:18",2
"Hyperledger Fabric","Encode MSPs into genesis block",,Sub-task,Medium,Closed,"2017-02-17 17:53:06","2017-02-17 17:53:06",1
"Hyperledger Fabric","Add simple tool to write out a genesis block","Please refer to the file {{configtxgen.md}} in the fabric/docs directory for usage of this tool.",Sub-task,Medium,Closed,"2017-02-17 16:57:19","2017-02-17 16:57:19",1
"Hyperledger Fabric","Add application and msp configuration to genesis.yaml",,Sub-task,Medium,Closed,"2017-02-17 16:22:22","2017-02-17 16:22:22",1
"Hyperledger Fabric","Add tool for creationg genesis material and creating config transactions",,Story,Medium,Closed,"2017-02-17 16:21:53","2017-02-17 16:21:53",5
"Hyperledger Fabric","Add reader/writer/admin policies to individual orgs",,Sub-task,Medium,Closed,"2017-02-17 07:25:26","2017-02-17 07:25:26",1
"Hyperledger Fabric","Add default reader/writer/admin policies to orderer genesis",,Sub-task,Medium,Closed,"2017-02-17 06:47:57","2017-02-17 06:47:57",1
"Hyperledger Fabric","Add implicit meta policy evaluation support to policy manager",,Sub-task,Medium,Closed,"2017-02-17 06:04:58","2017-02-17 06:04:58",1
"Hyperledger Fabric","Allow config items to specify modification policy relatively",,Sub-task,Medium,Closed,"2017-02-17 04:31:36","2017-02-17 04:31:36",1
"Hyperledger Fabric","Cleanup channel config values",,Sub-task,Medium,Closed,"2017-02-17 02:23:52","2017-02-17 02:23:52",1
"Hyperledger Fabric","Implement hierarchical policies storage",,Sub-task,Medium,Closed,"2017-02-16 22:39:50","2017-02-16 22:39:50",2
"Hyperledger Fabric","Move config value handlers to their own package",,Sub-task,Medium,Closed,"2017-02-16 21:00:01","2017-02-16 21:00:01",1
"Hyperledger Fabric","Split configtx manager into manager/config/update",,Sub-task,Medium,Closed,"2017-02-16 07:16:43","2017-02-16 07:16:43",1
"Hyperledger Fabric","Move handler instantiation into transactional path",,Sub-task,Medium,Closed,"2017-02-16 06:42:49","2017-02-16 06:42:49",2
"Hyperledger Fabric","Create ImplicitMetaPolicy policy type",,Sub-task,Medium,Closed,"2017-02-15 20:00:07","2017-02-15 20:00:07",1
"Hyperledger Fabric","Track MSP per org and prevent MSP ID changes in configtx",,Sub-task,Medium,Closed,"2017-02-15 19:22:31","2017-02-15 19:22:31",1
"Hyperledger Fabric","Move policy off of Handler to new PolicyHandler",,Sub-task,Medium,Closed,"2017-02-14 19:02:22","2017-02-14 19:02:22",1
"Hyperledger Fabric","Rename test config MSP to DEFAULT",,Sub-task,Medium,Closed,"2017-02-14 17:14:00","2017-02-14 17:14:00",1
"Hyperledger Fabric","Move anchor peers to app org level",,Sub-task,Medium,Closed,"2017-02-14 06:04:44","2017-02-14 06:04:44",1
"Hyperledger Fabric","Create organization config handler",,Sub-task,Medium,Closed,"2017-02-14 03:46:18","2017-02-14 03:46:18",1
"Hyperledger Fabric","Compute config from CONFIG_UPDATE or from CONFIG",,Sub-task,Medium,Closed,"2017-02-14 02:19:09","2017-02-14 02:19:09",1
"Hyperledger Fabric","Embed full CONFIG_UPDATE tx in CONFIG result",,Sub-task,Medium,Closed,"2017-02-13 16:31:02","2017-02-13 16:31:02",1
"Hyperledger Fabric","Rename CONFIGURATION_ to  CONFIG_","This brings the enums into line, using the word config everywhere instead of a mix of config and configuration.",Sub-task,Medium,Closed,"2017-02-13 14:40:00","2017-02-13 14:40:00",1
"Hyperledger Fabric","Initialize configtx manager from Config, not Writeset","As a transitional mechanism, the config currently depends on the WriteSet containing the entire configuration.  Instead, the config as written in the config envelope needs to be utilized.",Sub-task,Medium,Closed,"2017-02-12 18:34:20","2017-02-12 18:34:20",1
"Hyperledger Fabric","Generate new config from udpated config map","The configtx code currently shortcuts by assuming that the writeset contains exactly the entire config.  In order to support partial updates, this writeset should be overlayed on top of the existing config, then transformed back into a new config.",Sub-task,Medium,Closed,"2017-02-12 16:54:30","2017-02-12 16:54:30",1
"Hyperledger Fabric","Factor out configtx config map creation",,Sub-task,Medium,Closed,"2017-02-12 05:20:19","2017-02-12 05:20:19",1
"Hyperledger Fabric","Improve efficiency of subset function",,Sub-task,Medium,Closed,"2017-02-12 02:09:01","2017-02-12 02:09:01",1
"Hyperledger Fabric","Add ConfigUpdate proto","In order to stabilize the protos, the ConfigUpdate protos need to go in first.  The existing code can be adapted simply to depend on a ConfigUpdate write set which includes the entire config.  Then, the actual partial config updates can be built on top of it.",Sub-task,Medium,Closed,"2017-02-10 16:43:01","2017-02-10 16:43:01",1
"Hyperledger Fabric","Remove '*Next' from structures",,Sub-task,Medium,Closed,"2017-02-10 15:23:34","2017-02-10 15:23:34",1
"Hyperledger Fabric","Dynamically generate test genesis material",,Sub-task,Medium,Closed,"2017-02-10 05:55:02","2017-02-10 05:55:02",1
"Hyperledger Fabric","Move orderer provisional bootstrapper to common/configtx/tool",,Sub-task,Medium,Closed,"2017-02-10 02:58:42","2017-02-10 02:58:42",1
"Hyperledger Fabric","Move orderer genesis config to common",,Sub-task,Medium,Closed,"2017-02-10 02:42:18","2017-02-10 02:42:18",1
"Hyperledger Fabric","Move orderer viper enhancements to common","Before moving the orderer genesis generation to common, it needs the enhanced viper support added by the orderer.",Sub-task,Medium,Closed,"2017-02-09 20:09:47","2017-02-09 20:09:47",1
"Hyperledger Fabric","Split orderer config into local and genesis components","This split is necessary to prepare to migrate the orderer genesis creation into the common package to use as a starting point for generating genesis material.",Sub-task,Medium,Closed,"2017-02-09 19:37:35","2017-02-09 19:37:35",1
"Hyperledger Fabric","Migrate application config from ConfigItem to ConfigGroup",,Sub-task,Medium,Closed,"2017-02-09 18:18:30","2017-02-09 18:18:30",1
"Hyperledger Fabric","Migrate orderer config from ConfigItem to ConfigGroup",,Sub-task,Medium,Closed,"2017-02-09 18:09:20","2017-02-09 18:09:20",1
"Hyperledger Fabric","Migrate channel config from ConfigItem to ConfigGroup",,Sub-task,Medium,Closed,"2017-02-09 17:50:50","2017-02-09 17:50:50",1
"Hyperledger Fabric","Migrate configtx.Manager to parse ConfigNext","While integrating the ConfigNext proto, adapter code was written to convert it back to the original Config type.  This conversion code needs to go away, and as a first step, the configtx.Manager needs to begin using the updated format.",Sub-task,Medium,Closed,"2017-02-09 15:06:18","2017-02-09 15:06:18",3
"Hyperledger Fabric","Make hierarchical config components comparable",,Sub-task,Medium,Closed,"2017-02-09 04:38:25","2017-02-09 04:38:25",1
"Hyperledger Fabric","Initialize all config handlers via configtx initializer",,Sub-task,Medium,Closed,"2017-02-08 16:52:23","2017-02-08 16:52:23",1
"Hyperledger Fabric","Move MSP configtx handler to configtx/handlers",,Sub-task,Medium,Closed,"2017-02-08 15:55:54","2017-02-08 15:55:54",1
"Hyperledger Fabric","Move configtx filter to orderer","When configtx was moved from orderer to common it brought along the configtx.Filter, which is inherently an orderer concept and violates the rule of not importing from common into orderer.",Sub-task,Medium,Closed,"2017-02-08 04:54:03","2017-02-08 04:54:03",1
"Hyperledger Fabric","Create channel configtx schema",,Sub-task,Medium,Closed,"2017-02-07 21:18:33","2017-02-07 21:18:33",1
"Hyperledger Fabric","Create application configtx schema",,Sub-task,Medium,Closed,"2017-02-07 21:18:13","2017-02-07 21:18:13",1
"Hyperledger Fabric","Create orderer configtx schema",,Sub-task,Medium,Closed,"2017-02-07 21:17:52","2017-02-07 21:17:52",1
"Hyperledger Fabric","Add simple configuratoin schema protos","Because the new configtx format is so much more flexible than the original, we need to make sure that it is locked down to keep people from going crazy with it.  The restrictions can be relaxed as the use cases are made, but initially the goal is to restrict the configuration to a minimal set and loosen from there.    To do this, protos for a simple schema should be defined so that the configtx manager can enforce the restrictive configuration scheme.",Sub-task,Medium,Closed,"2017-02-07 21:10:27","2017-02-07 21:10:27",1
"Hyperledger Fabric","Move channel shared config to common","The orderer and application config were both recently moved to common.  For the sake of consistency, the channel config should be moved from its current location in common under configtx like orderer and application.",Sub-task,Medium,Closed,"2017-02-07 21:04:20","2017-02-07 21:04:20",1
"Hyperledger Fabric","Move application shared config from peer to common","Just as with the orderer configuration, having the peer configuration in a separate package is problematic, so this CR moves it to common.",Sub-task,Medium,Closed,"2017-02-07 20:34:50","2017-02-07 20:34:50",1
"Hyperledger Fabric","Move orderer shared config definitions to common",,Sub-task,Medium,Closed,"2017-02-07 20:11:58","2017-02-07 20:11:58",1
"Hyperledger Fabric","Add ConfigNext proto","Rather than modify the config protos and the config producers, parsing, and consumers all at once, this CR adds only the new protos, without removing the old, and makes the minimal changes required only to use the new proto format while on the wire.",Sub-task,Medium,Closed,"2017-02-07 18:29:03","2017-02-07 18:29:03",2
"Hyperledger Fabric","Remove xxxCryptoHelper to mocks","The real crypto helper was added, but the mock one was left in the real binary, moving to mocks.",Sub-task,Medium,Closed,"2017-02-07 18:23:09","2017-02-07 18:23:09",1
"Hyperledger Fabric","Consistently refer to Configuration* as Config in protos",,Sub-task,Medium,Closed,"2017-02-06 18:46:46","2017-02-06 18:46:46",1
"Hyperledger Fabric","Implement hierarchical configtx structure","The current configuration structure is a flat list, which causes some problems, especially when attempting to differentiate between the roles of ordering organizations and peer organizations.  A hierarchical model is slightly more complex from a data structure perspective, but is more natural and expressive.    This work should be careful to ensure that the older model can be supported in the degenerate case.",Story,Medium,Closed,"2017-02-06 18:46:08","2017-02-06 18:46:08",13
"Hyperledger Fabric","Move configtx signatures to be across whole config, not just individual items","The current configtx scheme is a collection of signed configuration items.  This has the benefit of being very flexible, allowing a submitter to collect signatures from one set of parties for one set of items, a second set of signatures from a second set of parties for a second set of items, and then glue them together, and submit a valid reconfiguration.    However, this flexibility comes at the expense of requiring more signatures, and the added complexity does not seem worth the added flexibility.  This CR moves the signatures to the envelope level, but maintains the per item policy evaluation.",Story,Medium,Closed,"2017-02-01 19:37:50","2017-02-01 19:37:50",3
"Hyperledger Fabric","Allow other chain hashing parameters","Per FAB-1700 and FAB-1699, the chain hashing parameters are now included in the chain configuration.  However, for the v1 release it was not practical to actually utilize these values, so instead they are required at a fixed size until they can be implemented.    The chainconfig.Descriptor carries these values, but no one is currently consuming them.    This additionally includes implementing a Merkle tree for the block data structure.",Story,Medium,Closed,"2017-02-01 15:02:32","2017-02-01 15:02:32",8
"Hyperledger Fabric","Remove ad-hoc MSP config block parsing","The MSP implemented its own custom config block parsing as a stopgap, it is no longer needed.",Sub-task,Medium,Closed,"2017-02-01 02:29:12","2017-02-01 02:29:12",1
"Hyperledger Fabric","Switch peer tests to utilize test templates","The peer already depends on the orderer template, but is not currently using the peer or MSP templates.  Where appropriate, especially the MSP template should be utilized.",Sub-task,Medium,Closed,"2017-01-31 18:58:17","2017-01-31 18:58:17",1
"Hyperledger Fabric","Cleanup templating to normalize across peer/orderer/msp",,Sub-task,Medium,Closed,"2017-01-31 17:08:06","2017-01-31 17:08:06",1
"Hyperledger Fabric","Create peer test template","Just like the orderer, and the MSPs, a peer test template needs to be created to facilitate tests which require a valid genesis block for a chain.",Sub-task,Medium,Closed,"2017-01-31 16:50:44","2017-01-31 16:50:44",1
"Hyperledger Fabric","Generate orderer template in tests.",,Sub-task,Medium,Closed,"2017-01-31 16:01:54","2017-01-31 16:01:54",1
"Hyperledger Fabric","Generate test genesis block in tests.","The unit tests require genesis materials for their chain, but this is currently a manual and hacky process.  This story is to fix this into a more automated flow.",Story,Medium,Closed,"2017-01-31 16:01:23","2017-01-31 16:01:23",3
"Hyperledger Fabric","Remove ChainHeader from ConfigurationItem","In preparation of having one header across an entire update, this needs to be removed from the individual items.",Sub-task,Medium,Closed,"2017-01-30 20:16:22","2017-01-30 20:16:22",1
"Hyperledger Fabric","Split configuration.proto into more meaningful delineations",,Sub-task,Medium,Closed,"2017-01-30 18:14:58","2017-01-30 18:14:58",1
"Hyperledger Fabric","Enable MVCC+Postimage for configtx","The current configuration tx scheme requires a global sequence number be specified.  This is problematic as a DoS attack vector if single signers are allowed for modification of items (like anchor peers, or MSP definitions).  It should be a relatively straightforward change to modify this to be MVCC+postimage to eliminate the DoS sequence number contention problem.",Story,Medium,Closed,"2017-01-27 03:08:07","2017-01-27 03:08:07",8
"Hyperledger Fabric","Update anchor peers to be multiple configuration items","Because write access to config is scoped by configuration item, it does not make sense for all anchor peers to be writable by any organization.  Instead, we should have one configuration item per anchor peer, with a modification policy corresponding to that org.",Story,Medium,Closed,"2017-01-26 21:39:05","2017-01-26 21:39:05",3
"Hyperledger Fabric","Introduce identity channel to orderer","There is an existing problem with syncing identity across channels.    # Application orgs cannot read the ordering system channel, so they cannot reasonably update their identity there.  # Application orgs cannot determine what channels they are a member of, so cannot easily script updates to their identity.  Further, because the identity may be at different levels and will definitely have different headers, one signature must be generated per channel.  # The orderer has no way to ensure that the MSP used in a channel creation request is up to date (except relative to the ordering system channel, which as already pointed out, is problematic to update).  # The orderer has no centralized place to get TLS certs from.  # The peer has no authoritative source for TLS certs or for local MSP data.  # If an application wishes to create a channel with an org they have no other channels with, it's not obvious how to retrieve their current MSP.    There are probably other benefits as well.",Story,Medium,Closed,"2017-01-26 21:37:08","2017-01-26 21:37:08",8
"Hyperledger Fabric","Add callback feature on configtx update","Per the gossip team, they require to be notified when the channel configuration changes.  This is to implement a way to push notification events to them.",Sub-task,Medium,Closed,"2017-01-25 19:04:59","2017-01-25 19:04:59",1
"Hyperledger Fabric","Creat peer sharedconfig descriptor",,Sub-task,Medium,Closed,"2017-01-25 16:37:04","2017-01-25 16:37:04",1
"Hyperledger Fabric","Add peer configtx.Handler",,Story,Medium,Closed,"2017-01-25 16:16:39","2017-01-25 16:16:39",1
"Hyperledger Fabric","Initialize MSP through MSP config handler hooks",,Sub-task,Medium,Closed,"2017-01-24 17:45:24","2017-01-24 17:45:24",1
"Hyperledger Fabric","Pass configtx.Manager to TxValidator",,Sub-task,Medium,Closed,"2017-01-23 23:07:21","2017-01-23 23:07:21",1
"Hyperledger Fabric","As a chaincode developer, I want to chaincode to chaincode invocations across channels to support writes",,Story,Medium,"To Do","2017-01-20 21:55:23","2017-01-20 21:55:23",4
"Hyperledger Fabric","Delete Me Please",,Sub-task,Medium,Closed,"2017-01-20 06:43:46","2017-01-20 06:43:46",1
"Hyperledger Fabric","Add chain config to common configtx.Manager",,Sub-task,Medium,Closed,"2017-01-20 05:06:47","2017-01-20 05:06:47",1
"Hyperledger Fabric","Refactor orderer multichain package to prep for chainconfig","The orderer multichain package has become a little unwieldy as more and more configuration based handlers have been added to it.  This changeset consolidates these many parameters into embedded structures to alleviate this problem in preparation for adding the chain config handler.",Sub-task,Medium,Closed,"2017-01-20 04:55:04","2017-01-20 04:55:04",1
"Hyperledger Fabric","Move policy manager creation to common components","The policy manager is currently only initialized within the orderer, but this is a common function and needs to be moved into the common components.",Sub-task,Medium,Closed,"2017-01-20 04:35:20","2017-01-20 04:35:20",1
"Hyperledger Fabric","Add chain config mock structures",,Sub-task,Medium,Closed,"2017-01-19 21:41:14","2017-01-19 21:41:14",1
"Hyperledger Fabric","Flag use of the config block as deprecated",,Sub-task,Medium,Closed,"2017-01-19 17:01:55","2017-01-19 17:01:55",1
"Hyperledger Fabric","Integrate configtx.Manager into peer","The peer currently uses the dangerous and deprecated method of manually inspecting configuration blocks for configuration.  This has a multitude of security and correctness problems, but also produces a lot of redundant and unnecessary code.  The peer should be converted to utilize the existing configtx.Manager code which does proper configuration transaction validation and provides a simple interface for users of that configuration.",Story,Medium,Closed,"2017-01-19 17:01:14","2017-01-19 17:01:14",3
"Hyperledger Fabric","Refactor provisional bootstrap generator","The old provisional bootstrapper was becoming increasingly convoluted for doing very little, this changeset deletes must/most of that code in favor of a much simpler approach.",Sub-task,Medium,Closed,"2017-01-19 03:38:12","2017-01-19 03:38:12",1
"Hyperledger Fabric","Add utility method for generating policy config items",,Sub-task,Medium,Closed,"2017-01-19 03:14:00","2017-01-19 03:14:00",1
"Hyperledger Fabric","Add utility methods for generating orderer config items",,Sub-task,Medium,Closed,"2017-01-19 02:47:01","2017-01-19 02:47:01",1
"Hyperledger Fabric","Add utility methods for generating chain config items",,Sub-task,Medium,Closed,"2017-01-19 02:10:51","2017-01-19 02:10:51",1
"Hyperledger Fabric","Add orderer addresses configuration item","Add a configuration item which will let the peers know in `JoinChannel` which orderer addresses may be connected to.",Story,Medium,Closed,"2017-01-17 21:23:23","2017-01-17 21:23:23",1
"Hyperledger Fabric","Enhance orderer startup and ingress/egress logging quality.","The orderer debugging output is not as helpful as it ought to be, in particular it doesn't mention which policy is not being evaluated correctly, or that startup actually completes, etc.  This should be fixed.",Story,Medium,Closed,"2017-01-16 21:06:08","2017-01-16 21:06:08",1
"Hyperledger Fabric","Create initial developer oriented config tx viewer.",,Sub-task,Medium,Closed,"2017-01-16 20:46:45","2017-01-16 20:46:45",2
"Hyperledger Fabric","As an admin and developer, I need a way to inspect and create configuration transactions","This story is to start working on the tools necessary for admins to work with configuration transactions, not only creating them, but also inspecting and signing them.    There are four principal components to this issue.    1. Bidirectional proto <=> deep JSON translation:  This is at the heart of the issue, and provides both a human readable, and human editable version of the configuration.  Because the configuration embeds other message types, like {{Envelope}} it is most natural to make this a generic proto <=> deeply unmarshaled JSON.  This means that the output should, to the extent possible, contain no binary marshaled fields.  For instance, a {{Block}} should show nested {{Envelope}} messages in its data, and these messages should show {{Payload}} messages, which should in tern show the unmarshaled version of the {{Data}} field, etc.  Correspondingly, it is important that this mapping be able to be returned into the native proto form.  Note, that the bidirectional marshaling can preserve meaning only, not literal bytes, as proto marshaling is non-deterministic.    2. A Config + Config -> ConfigUpdate utility:  This will allow the user to submit an original config and a modified config to produce a config update.  This will combine naturally with (1), so that the user may view the configuration in a human readable way, edit it, compute the update, and then see the update in a human readable form.    3. A REST API which exposes (1) and (2).    4. A CLI which exposes (1) and (2)    Finally, we may wish to add one additional API to (3)/(4), namely the ability to submit a Config, a Config Update, and have the server do a simulation of the result (including any errors produced because of insufficient signatures, or bad form).    For those interested in getting a jump on interacting with the deep JSON representation, please see a (unusually verbose) config update message attached as output_pretty.txt.",Story,Medium,Closed,"2017-01-16 20:45:15","2017-01-16 20:45:15",8
"Hyperledger Fabric","Fix misleading and problematic chain-config.proto","The chain-config.proto file is misleadingly named, as it contains only MSP principal things.  The hyphen in the name is also causing problems with the proto generation for the python bdd, so this should be changed.",Sub-task,Medium,Closed,"2017-01-13 21:50:35","2017-01-13 21:50:35",1
"Hyperledger Fabric","Normalize the orderer configuration item names and conventions","The orderer configuration items have been added one by one as needed, so some commonalities have been ignored, and some names are inconsitent or misleading.  This story is to normalize those names.",Story,Medium,Closed,"2017-01-13 20:34:39","2017-01-13 20:34:39",2
"Hyperledger Fabric","Add restart support",,Story,Medium,Closed,"2017-01-12 18:12:50","2017-01-12 18:12:50",3
"Hyperledger Fabric","Create configuration template for orderer user to consume","The orderer is currently hackily copying code from the orderer bootstrapper to generate the new chain request.  This is not a real path, as this needs to be supplied by the orderer, this story should address that.",Story,Medium,Closed,"2017-01-11 22:31:39","2017-01-11 22:31:39",3
"Hyperledger Fabric","Incorrect marshalling of transaction into block during block event generation","Block delivered by events is not in the correct format.",Sub-task,Highest,Closed,"2017-01-11 18:52:48","2017-01-11 18:52:48",1
"Hyperledger Fabric","Hook deliver policy filtering into main code path",,Sub-task,Medium,Closed,"2017-01-10 01:40:00","2017-01-10 01:40:00",1
"Hyperledger Fabric","Deliver API needs to check signatures against egress policy","The deliver API will support signatures after FAB-1573, so it then needs to actually respect these signatures and only allow readers which are authorized by policy for a given chain.",Story,Medium,Closed,"2017-01-09 23:05:59","2017-01-09 23:05:59",1
"Hyperledger Fabric","Deliver messages need to be signable","The deliver message currently has no authentication associated with it.  Rather than invent yet another signing scheme, we should adapt the Envelope message to be used to send SeekInfo requests.",Story,Medium,Closed,"2017-01-09 22:05:55","2017-01-09 22:05:55",2
"Hyperledger Fabric","Orderers need to filter incoming Broadcast messages by signature","The framework to filter incoming transactions exist, as does the framework to manage policies, but currently the filtering framework does no policy enforcement on incoming broadcast messages, this needs to be fixed.",Story,Medium,Closed,"2017-01-09 18:22:04","2017-01-09 18:22:04",2
"Hyperledger Fabric","create new repo for fabric-runtime","create a new gerrit repo and github mirror for 'fabric-runtime' per the proposal by <USER>[1]. As with other fabric projects, please list all current Fabric maintainers as maintainers.    [1] https://lists.hyperledger.org/pipermail/hyperledger-fabric/2017-January/000510.html",Task,Medium,Closed,"2017-01-07 21:36:09","2017-01-07 21:36:09",1
"Hyperledger Fabric","Properly initialize the signature field of the block metadata",,Story,Medium,Closed,"2017-01-05 20:15:20","2017-01-05 20:15:20",1
"Hyperledger Fabric","Appropriately get configuration from block metadata on orderer restart","The orderer needs to initialize the configuration for every chain, identify the ordering system chain specially, and initialize the other chains.",Sub-task,Medium,Closed,"2017-01-05 07:03:58","2017-01-05 07:03:58",1
"Hyperledger Fabric","Populate metadata last configuration field","Each block is supposed to contain a reference to the last configuration block, the configuration of which that block was generated under.    Although this is a separate requirement needed for instance for gossip, this is also useful for supporting restart of the ordering service so is being classified as a sub-task of FAB-1299.",Sub-task,Medium,Closed,"2017-01-05 05:47:12","2017-01-05 05:47:12",1
"Hyperledger Fabric","Fix orderer rawledger interface to support restart","The rawledger interface was originally implemented as a single chain initialized with a genesis block.  This causes problems on restart because a newer genesis block may already exist and passing the genesis block becomes nonsensical.",Sub-task,Medium,Closed,"2017-01-05 02:39:02","2017-01-05 02:39:02",2
"Hyperledger Fabric","As a fabric developer, I want to plugin a new state database, simulation scheme, validation scheme",,Story,High,Closed,"2017-01-03 14:21:39","2017-01-03 14:21:39",8
"Hyperledger Fabric","Ledger history: When looking at the ledger history for a key, I want to see history with full transactional context ","In addition to seeing the history of key values, we should be able to see the full transaction details for every update to the key.  This will require defining a new transaction structure to be returned.",Story,Medium,Closed,"2017-01-03 14:11:34","2017-01-03 14:11:34",8
"Hyperledger Fabric","Ledger history: I want a chaincode API to see the history of key values (using LevelDB)",,Story,Medium,Closed,"2017-01-03 14:08:22","2017-01-03 14:08:22",4
"Hyperledger Fabric","Ledger history recovery: I want to be sure that the history database is in sync with the blockchain and state database",,Story,Medium,Closed,"2017-01-03 13:59:07","2017-01-03 13:59:07",4
"Hyperledger Fabric","Add safesql to CI for go-based components","Add https://github.com/stripe/safesql to our CI pipelines for all golang components that utilize a database. This will enhance our security by finding any potential SQL injection vulnerabilities before they are merged.",Task,High,Closed,"2016-12-18 14:35:48","2016-12-18 14:35:48",2
"Hyperledger Fabric","Behave backend utilities","A test writer should be able to write feature tests using backend utilities to drive the tests such that any new test scenario can utilize the APIs while keeping the modification of the backend to a minimum.    *Output:* back-end utility functionality that drives the feature files. These utilities will include (but not limited to):    * docker_util    * remote_util   * grpc_util   * shell_util  ",Story,Medium,Closed,"2016-12-16 17:07:53","2016-12-16 17:07:53",5
"Hyperledger Fabric","Implement epoch and timestamp message replay protection","The envelope header contains a timestamp and epoch both of which are ignored by the ordering service today. But, these should be leveraged for message replay prevention.    This will require synchronizing with the SDK/peer team to make sure these parameters are correctly set.",Story,Medium,Closed,"2016-12-16 15:06:20","2016-12-16 15:06:20",5
"Hyperledger Fabric","Ledger setInfo(): As a chaincode author, I want to pass information to VSCC for transaction validation context","Proposal is to add a setInfo() on the simulator, for the chaincode to pass some transaction context that is to be used later for validation in VSCC, without anything getting written to permanent state (therefore don't want to use WriteSet).  This information would get included in the simulation results in the transaction, and VSCC would be able to reference it when performing custom validation logic.    (Murali, please fill in your immediate use case for it).",Story,High,Closed,"2016-12-15 20:12:14","2016-12-15 20:12:14",2
"Hyperledger Fabric","Convert signature policy to pluggable policy provider model",,Sub-task,Medium,Closed,"2016-12-15 19:55:07","2016-12-15 19:55:07",2
"Hyperledger Fabric","Convert Policy from oneof to enum","The Policy type for configuration is currently oneof{ SignaturePolicyEnvelope }.    This is somewhat convenient but is not extensible without modification of the common protos.    Instead, this should be switched to be the standard enumerated type, bytes model.",Sub-task,Medium,Closed,"2016-12-15 19:53:47","2016-12-15 19:53:47",1
"Hyperledger Fabric","Make policy manager pluggable with different policy providers","Per discussion with [~<USER> [~adecaro] and [~<USER> the MSP managers would like to provide their own policy evaluation options.  This would be in addition to the NOutOf policies, but would exist within the current framework.    This story is to make the existing policy manager pluggable with different policy providers, so that the MSP manager may provide a policy provider for MSP type policies.",Story,Medium,Closed,"2016-12-15 17:37:56","2016-12-15 17:37:56",3
"Hyperledger Fabric","Refactor ledger interface name for RawLedger and ValidatedLedger","As was suggested by [~<USER> in CR (https://gerrit.hyperledger.org/r/#/c/3259/) related to FAB-1384    {quote}  The other thing I wanted to mention, is that with this changeset, the committer's ledger is no longer a 'ValidatedLedger' (invalid tx removed). Rather it is now a raw ledger (with invalid tx marked). Therefore instead of keeping the names RawLedger and ValidatedLedger in ledger_interface.go, I think the more accurate names would now be OrdererLedger and CommitterLedger, respectively. These names would be more expressive for their intended use. Let's see if Manish agrees.  {quote}    and according to [~<USER>    {quote}  Yes, I'm fine with the new names proposed by Dave. But, I think that we can change that later in a separate commit - in order to keep the  conflicts with the refactoring to low.  {quote}    Creating new story to follow up on that and eventually refactor interfaces names.",Story,Medium,Closed,"2016-12-14 10:39:42","2016-12-14 10:39:42",4
"Hyperledger Fabric","Remove windowing concept from the Deliver API","Per some performance testing feedback from [~<USER> it's much more efficient if we allow HTTP2/gRPC to handle the connection data windowing rather than attempting to implement it ourselves at a higher layer.    In order to remove windowing from deliver, there must be some other mechanism supplied to allow a client to retrieve a specific number of blocks.  This means that the Deliver API must also be enhanced to allow range specification.",Story,Medium,Closed,"2016-12-13 15:48:40","2016-12-13 15:48:40",3
"Hyperledger Fabric","Remove bd_counter sample client","I wrote this while developing the Kafka orderer for testing. The existing sample clients (broadcast_timestamp and deliver_stdout) provide the same functionality and in a more modular, Unix-like way. Keeping the bd_counter around just increases maintenance burden.",Task,Medium,Closed,"2016-12-12 20:07:32","2016-12-12 20:07:32",1
"Hyperledger Fabric","Rebase Kafka consenter on common components",,Story,Medium,Closed,"2016-12-12 05:15:34","2016-12-12 05:15:34",8
"Hyperledger Fabric","Update Docker Compose files for Kafka consenter","We should either list only those ENV vars where we need to modify the default values, or list all possible ENV vars to allow for easy editing later on. The Docker Compose files in their present form adopt a middle-ground solution: list only some ENV vars, and have several of them set to the default values.",Task,Medium,Closed,"2016-12-12 05:13:31","2016-12-12 05:13:31",1
"Hyperledger Fabric","Introduce Kafka-specific container message types","The revised Kafka consenter needs two special messages:    # A time-to-cut message that is used to mark the end of a block, and  # A no-op message that each shim posts when bootstrapped by the multichain manager to prevent the possibility of listening in (seeking and consuming) on a topic/partition that nobody has posted to yet [1]. This is an operation that panics in Kafka: [ERROR] Cannot retrieve required offset from Kafka cluster: kafka server: The request attempted to perform an operation on an invalid topic.    These messages are special because they don't carry transactions, and because the Kafka consenter will treat them in a special way: it will ignore every time-to-cut message (for a specific block number) besides the first one, and it will ignore all no-op messages when processing incoming messages from the chain partition.    A preview of these in action can be found here:  https://github.com/<USER>fabric/blob/47752ed61fcab1b26207a9e9075c1c793d723912/orderer/kafka/main.go#L142  https://github.com/<USER>fabric/blob/47752ed61fcab1b26207a9e9075c1c793d723912/orderer/kafka/main.go#L164  https://github.com/<USER>fabric/blob/47752ed61fcab1b26207a9e9075c1c793d723912/orderer/kafka/main.go#L204",Task,Medium,Closed,"2016-12-12 05:11:28","2016-12-12 05:11:28",1
"Hyperledger Fabric","Replace static bootstrapper with provisional one","All consenters read several of their config settings (think sharedconfig) from the genesis block that is generated by a bootstrapper. The only bootstrapper available so far is the static one. However, when testing we need to be able to modify several of these config values on the fly.    Therefore the bootstrapper should be able to read a config object (which is itself created by reading the orderer.yaml file and -if set- its associated ENV vars).    An example of that would be the KafkaBrokers value. For unit tests the right value is 127.0.0.1:9092, whereas for the current Docker Compose-based BDD tests the right value is kafka0:9092.    Since this bootstrapper is no longer static, renaming the package seems appropriate.    For production we will need to introduce file-based bootstrapper that reads the genesis block created by the genesis block tool.",Task,Medium,Closed,"2016-12-12 05:09:34","2016-12-12 05:09:34",2
"Hyperledger Fabric","Move ChainID method to ConsenterSupport","What necessitates this move is that the Kafka multichain.Chain object returned/expected by HandleChain(), needs to be able to allocate the resources necessary to keep up with its respective chain when the Start() method is invoked by the multichain manager, as the contract of the Chain interface (defined in chainsupport.go) dictates.    Keeping up with the respective chain means that the Kafka multichain.Chain object needs to bring up a producer/consumer that connects to the corresponding chain partition, so it needs to know the chain ID. The only object passed to us during the HandleChain call is an object of type multichain.ConsenterSupport. Therefore, this interface needs to be extended with the ChainID() method.    I've noted the need for this during my review of this changeset:  https://gerrit.hyperledger.org/r/#/c/2763/ (skip to the comment timestamped 11-27 18:52, and its follow-up comment)    If you want to see how this will look in action for the Kafka consenter (coming in a follow-up changeset), please see:  https://github.com/<USER>fabric/blob/47752ed61fcab1b26207a9e9075c1c793d723912/orderer/kafka/main.go#L128  https://github.com/<USER>fabric/blob/47752ed61fcab1b26207a9e9075c1c793d723912/orderer/kafka/main.go#L143",Task,Medium,Closed,"2016-12-12 05:07:07","2016-12-12 05:07:07",1
"Hyperledger Fabric","Add KafkaBrokers to shared config","The list of Kafka brokers used for ordering needs to be shared across the shims (ordering service nodes).",Task,Medium,Closed,"2016-12-12 05:04:02","2016-12-12 05:04:02",1
"Hyperledger Fabric","Move partitioner-related functions to own file",,Task,Medium,Closed,"2016-12-12 05:02:35","2016-12-12 05:02:35",1
"Hyperledger Fabric","Introduce ChainPartition construct for Kafka","The ChainPartition construct will be used to identify the Kafka topic/partition that the ordering shims should interact with when dealing with a particular chain.",Task,Medium,Closed,"2016-12-12 04:59:15","2016-12-12 04:59:15",1
"Hyperledger Fabric","Drop custom flag support for Kafka orderer","As we are slowly moving to a setup where the behavior of the orderer is controlled by the config options captured in the genesis block and the orderer YAML file (and their overrides via ENV vars), it's time to drop the flag support that the Kafka orderer provided.    * Remove all flags from the Kafka orderer.  * Add a verbose option to the YAML file to control logging for the package that we use to interact with the Kafka cluster (sarama).",Task,Medium,Closed,"2016-12-12 04:57:23","2016-12-12 04:57:23",1
"Hyperledger Fabric","Convert all batchSize refs to the uint32 type","Address the mismatch between the batchSize type as expressed in the localconfig package versus the sharedconfig package and the orderer configuration proto.",Task,Medium,Closed,"2016-12-12 04:55:23","2016-12-12 04:55:23",1
"Hyperledger Fabric","Add time-based block cutting to Kafka consenter","In the version that was rebased on top of the common components, this option was kept out in order to minimize the complexity of the changeset. The deliverable of this story is a Kafka consenter that respects the BatchTimeout config option.    ",Story,Medium,Closed,"2016-12-11 08:16:14","2016-12-11 08:16:14",3
"Hyperledger Fabric","Update broadcast_config sample client so that it posts appropriate config for Kafka consenter","As things stand right now, the config it posts only works for solo. The client should have an extra flag that allows us to specify the consenter type, and then, by using the provisional bootstrapper, it should create the appropriate config.",Story,Medium,Closed,"2016-12-11 05:15:15","2016-12-11 05:15:15",1
"Hyperledger Fabric","Enforce restrictions on acceptable chain IDs","This is motivated by the fact that Kafka imposes restrictions on the allowed topic names:  https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/common/Topic.scala#L29    Regardless of that, we should adopt similar restrictions.    Ideally, these will be a superset of the Kafka restriction set so that we don't have to add any extra code for the Kafka consenter case.",Story,Medium,Closed,"2016-12-10 20:29:21","2016-12-10 20:29:21",1
"Hyperledger Fabric","as a potential Fabric application developer, I want to have up-to-date documentation while v1.0 is under development","as a potential Fabric application developer, I want to have up-to-date documentation while v1.0 is under development. Specifically, I want to be directed to v0.6 if I am looking for stable operational platform, and I want to have documentation about how to use the v1.0 Fabric as it is being developed.",Story,Medium,Closed,"2016-12-10 15:00:32","2016-12-10 15:00:32",2
"Hyperledger Fabric","BDD tests: Kafka orderer should be resilient to faults","     The following are the details for these tests.   * +Component+:  orderer   * +Description+:  Test scenarios with faults in the Kafka brokers, and the orderer shims.   * +Artifact Locations+:  test/feature/orderer.feature   * +Network Topology+:  3 orderers, 3 zookeepers, 4 kafka brokers, 4 peers   * +Client Driver+: behave    This test should show that as the partition leader changes, the network still functions as expected.",Sub-task,Medium,Closed,"2016-12-09 18:13:55","2016-12-09 18:13:55",3
"Hyperledger Fabric","Decide on block hashing specifics","Today, the orderer is using the functions defined in `fabric/protos/common/block.go` for hashing the block header and data.    These functions are _definitely_ wrong, and were never intended to be long term solutions.  These functions need to be fixed to use a hashing algorithm and marshalling scheme (and possibly using a wide Merkle Tree for the BlockData).    This was discussed somewhat extensively in https://gerrit.hyperledger.org/r/#/c/1361/ but no conclusion was reached.",Story,Medium,Closed,"2016-12-09 17:51:31","2016-12-09 17:51:31",3
"Hyperledger Fabric","Make orderer logging configurable (in a centralized way)","Today, the orderer initializes loggers in almost every package, and statically sets their logging levels.  This was easy to speed development along, but this really needs to be configurable for the whole ordering process in a sane way, ideally lifted from the peer flogging stuff.",Story,Medium,Closed,"2016-12-09 17:44:01","2016-12-09 17:44:01",3
"Hyperledger Fabric","I want to be able to read from CouchDB state database as an 'external' user (not using the peer's admin user)","Currently only two modes are available when using CouchDB - completely open (no user security) and completely locked down (user security enabled).  Production environments utilize the locked down configuration, while development environments may decide to skip user security in order to allow direct access.    If user security is enabled, only the peer's admin user can read/write to CouchDB.  No other 'external' users can access CouchDB - access is locked down and all requests must go through the peer's CouchDB user.    If it is desired to have 'external' users be able to read (only) CouchDB directly, two changes would be required:    1) Add the 'external' users to the CouchDB database security object as members.  See http://docs.couchdb.org/en/2.2.0/api/database/security.html .  Currently peer writes the database security object with just the peer's admin user upon each startup (allowing for the ability to change the username).  Note - it may be possible to use a server admin instead of setting the admins role on each database, and only populate the members role.     2) Any database 'member' would have both read and write access.  To lock it down for read access only, a CouchDB 'validation function' (deployed as a design document to CouchDB) would be required, it could enforce that only the peer's admin user could perform writes.",Story,High,Closed,"2016-12-08 15:10:58","2016-12-08 15:10:58",8
"Hyperledger Fabric","Hook into fabric ledger for rawledger implementation","The orderer currently relies on its own rawledger implementations, a simple ram based ledger (which does not persist anything to disk) and a simple file based ledger which uses a very naive JSON encoding with 1 block per file.    Neither of these are likely to scale well for real systems and have always been intended to be testing tools while the real ledger is developed.    A shim needs to be written between the orderer rawledger API and the fabric ledger api to support deploying with the fabric backing ledger for production deployments.",Story,Medium,Closed,"2016-12-07 22:10:21","2016-12-07 22:10:21",13
"Hyperledger Fabric","Add config inspection validation on chain creation transaction","Today, chain creation requests are only validated based on the fact that they are well formed, and signed according to the policy for chain creation.    There is no checking to make sure that the orderers are specified correctly, that the orderer MSPs are included, etc.    What these checks are need to be determined as part of this story, as well as their implementation.  There is a plug point in the multichain systemChain.go code which is meant to handle this, but it currently is mostly a no-op.",Story,Medium,Closed,"2016-12-07 22:00:45","2016-12-07 22:00:45",3
"Hyperledger Fabric","Provide metrics for the common orderer service endpoints","In order to assess the health of the ordering service, we should expose basic metrics about the state of the ordering network like number of clients connected, transaction rates, chains and chain heights, etc.",Story,Medium,Closed,"2016-12-07 21:55:25","2016-12-07 21:55:25",5
"Hyperledger Fabric","Support orderer multichain restart","The multichain work introduced a significant amount of state tracking and updating on a per chain basis.  This state needs to be stored in such a way that when the orderer restarts, it can restart all of the chains which were created and do so with their correct config.    This should additionally support whatever metadata that a consenter needs for restart, such as in the kafka case the last offset committed.",Story,Medium,Closed,"2016-12-07 21:26:24","2016-12-07 21:26:24",4
"Hyperledger Fabric","Remove queueing concept from Broadcast","The broadcast API suffers from a deficiency today, that it immediately returns success/failure before the request has actually entered consensus.    The desired behavior would be to return success only after the request has entered consensus, but, this poses a problem when the broadcast queue overflows.  In the event that the broadcast queue overflows, incoming requests should be rejected to alert the client to slow down.    This results in the situation of:  1. Wait until after the queue drains to return the failure (which will not throttle the client and not provide immediate feedback, this is bad)  2. Return the success before the queue drains (which will not inform the client if for whatever reason the consensus system never actually accepts the request)    Since these options both have drawbacks and are mutually exclusive, a different solution is required.    This story is to add windowing to the broadcast API to mirror the deliver API.  If the client knows how big the buffer is at the server, then the client can delay sending new messages until it receives the success/failure after processing the queue.  If the client violates the protocol and overflows the queue, the client can be dismissed as malicious and hung-up on.",Story,Medium,Closed,"2016-12-07 20:54:57","2016-12-07 20:54:57",2
"Hyperledger Fabric","Create fabric common components directory and move orderer shared components there","The orderer has some common code which is of broader use to the fabric at large, not just the orderer.    In particularly, the configuration block parsing, and the policy parsing and evaluation are prime candidates for being shared in a modular way between the orderer and peer (and possibly other components).    This is being created in part by the request of [~<USER> to faciliate some VSCC ESCC work.",Story,Medium,Closed,"2016-12-05 22:23:23","2016-12-05 22:23:23",1
"Hyperledger Fabric","Create orderer generic multichain creation mechanism","Because every consensus type (Kafka, SBFT, Solo) will need to handle chain creation and management, it makes sense to write this as a layer outside of the actual consensus implementation.    This should include intercepting chain creation requests and routing them to the ordering system channel, and invoking the constructors for the backing resources once the request has been ordered.",Story,Medium,Closed,"2016-12-05 21:30:25","2016-12-05 21:30:25",4
"Hyperledger Fabric","Introduce generic notion of execution in the orderer","For the impending chain creation work, a second type of transaction will need to be 'executed' beyond a configuration transaction. This store is to generalizes the old configuration specific code paths into a re-usable path.    In particular, the broadcast filters must be generalized to be a more generic filtering mechanism.  Instead of replying with the matched rule type, and then having the invoker make decisions based on the match, the filters should return a Committer which can perform those actions with no specific knowledge from the caller.",Story,Medium,Closed,"2016-12-05 21:18:54","2016-12-05 21:18:54",3
"Hyperledger Fabric","As a chaincode developer, I want to use JSON-based data structures instead of table-based data structures, so that I have more control over queries","Remove Table API from Hyperleger Fabric in v1.  * The v0.5/v0.6 Pseedo-table API does not map well to current or next generation Fabric capabilities   * Project teams have been confused and frustrated with table API limitations    Encourage all new chaincode to use JSON-based data structures  * Additional query benefits when using CouchDB state database  * Provide JSON-based samples to help community update table-based chaincode  * Initial sample: https://github.com/<USER>table_to_json/blob/master/chaincode/table_to_json_chaincode.go    In the future Fabric may add support for relational state databases  * At that time it will make sense to introduce a ‘real’ table API without the limitations of the current pseudo-table API  ",Story,High,Closed,"2016-12-03 16:00:37","2016-12-03 16:00:37",8
"Hyperledger Fabric","Evolve from Vagrant to Docker based build","Docker based build and test eliminating need for vagrant.",Epic,Medium,Closed,"2016-11-22 20:43:29","2016-11-22 20:43:29",8
"Hyperledger Fabric","Specify path to orderer.yaml via an environment variable","Allow an user to specify where on the file system the orderer configuration yaml file is located.    This makes orderer consistent with peer ( and its PEER_CONFIG_PATH ) and allows for easier creation of the docker image.",Task,Medium,Closed,"2016-11-21 19:34:26","2016-11-21 19:34:26",1
"Hyperledger Fabric","Side DB - Channel Private Data - experimental feature","* As a Fabric deployer, I would like to maintain data such that only its evidence is exposed to the chain, ordering service, and channel peers while the data itself is disseminated to peers based on policy, so that we can achieve finer-grained data confidentiality for transactions while still maintaining ledger consistency and still being able to leverage Fabric for both data evidence and dissemination of the data (but in a more private fashion).    *Design*     Slides attached.",Epic,High,Closed,"2016-11-19 00:47:40","2016-11-19 00:47:40",40
"Hyperledger Fabric","Bootstrap BDD","Implement bootstrap BDD feature.  This feature will for the basis from which all future features will be based wrt to system composition.",Epic,Medium,Closed,"2016-11-17 19:49:17","2016-11-17 19:49:17",3
"Hyperledger Fabric","Need utilities to break out a Block and get the ConfigurationEnvelope","We have multiple places in the code where we need to unmarshall multiple things to get from Block to ConfigurationEnvelope.    Create a set of utility functions that can be called from anywhere",Sub-task,Medium,Closed,"2016-11-11 21:57:00","2016-11-11 21:57:00",1
"Hyperledger Fabric","Peer administration: Ledger rebuild state and indexes from block storage - test and document","If the blockstorage indexes and/or state database gets corrupted, we need to rebuild from the blockstorage on the file system.  ",Story,Highest,"To Do","2016-11-08 19:09:45","2016-11-08 19:09:45",4
"Hyperledger Fabric","Ledger consistent simulation (Block height option): As a consumer or ledger APIs (endorser), I want to perform proposal simulation using a consistent view of ledger state","Consistent reads has been implemented by using locks between readers and writers.  This task would implement consistent reads by using block height approach, so that reads and writes can occur in parallel.",Story,Medium,Closed,"2016-11-08 17:58:05","2016-11-08 17:58:05",4
"Hyperledger Fabric","SDK tells peers to join a channel","SDK should provides a function JoinChannel for the application to call. The parameters should include a hash of the genesis block and a list of peers belonging to the channel.    In turns, SDK send TX Proposal to each peer invoking CSCC.joinChannel, passing the genesis block hash and the list of peers.    See this document for an overview of the interactions among the various roles (app, SDK, orderer, peer): https://docs.google.com/document/d/1R5RtIBMW9fZpli37E5Li5_Q9ve3BnQ4q3gWmGZj6Sv4/edit#",Task,Medium,Closed,"2016-11-08 16:13:34","2016-11-08 16:13:34",4
"Hyperledger Fabric","Add unit tests for ledger applications on Fabric 1.0","Add unit tests to example.go application in ledger examples.",Story,High,Closed,"2016-11-07 21:34:27","2016-11-07 21:34:27",2
"Hyperledger Fabric","Turn validated new-chain configuration envelope into proper genesis block","The ordering node should be able to turn a validated new-chain configuration envelope into a proper genesis block. The ordering logic will then be able to get that block directly and push it to the new chain, and also set-up all the related logic (cutBlock goroutine, etc.) based on the parameters extracted from that genesis block (batchTimeout, batchSize), etc.",Task,High,Closed,"2016-11-07 17:16:26","2016-11-07 17:16:26",0
"Hyperledger Fabric","Remove request inspection and processing from the hot path in the Broadcast function",,Task,Medium,Closed,"2016-11-06 16:05:46","2016-11-06 16:05:46",0
"Hyperledger Fabric","Remove envelope marshaling from the hot path in the cutBlock goroutine",,Task,Medium,Closed,"2016-11-06 16:05:09","2016-11-06 16:05:09",0
"Hyperledger Fabric","Write test client that sends configuration envelope for new chain creation","This is part of the FAB-819 story. The goal is to use the broadcast_configuration client to send out a transaction that calls for the creation of a new channel. Then we will use the bd_counter client to make sure messages show up on the new channel.",Task,High,Closed,"2016-11-06 16:04:38","2016-11-06 16:04:38",1
"Hyperledger Fabric","Fix failing unit tests",,Task,Medium,Closed,"2016-11-06 16:04:08","2016-11-06 16:04:08",2
"Hyperledger Fabric","Add a commons/util package","The point is to not have to rewrite the same common utility functions again and again.    This is what I have so far:    # Marshal(pb proto.Message) []byte  # Hash(data []byte) []byte  # ExtractEnvelope(block *ab.Block, index int) (envelope *ab.Envelope, err error)  # ExtractPayload(envelope *ab.Envelope) *ab.Payload    The Hash function exists in the core util package as ComputeCryptoHash, so I may have to remove that in the end. I'm doing it now cause I want to switch to SHA-2 (FAB-887).",Task,Medium,Closed,"2016-11-06 16:03:31","2016-11-06 16:03:31",1
"Hyperledger Fabric","Rewrite Broadcaster so as to support ChainPartitions and DataHolders","The Broadcaster creates a DataHolder reference and spawns a cutBlock goroutine for every chain that is created. It keeps track of which goroutines are running, and can terminate them if need be.",Task,Medium,Closed,"2016-11-06 15:56:16","2016-11-06 15:56:16",2
"Hyperledger Fabric","Create DataHolder type","Holds all the data that the Broadcaster needs to keep track of, in order to eventually send a new block on the chain. There is a 1-to-1 mapping between chains and DataHolders.",Task,Medium,Closed,"2016-11-06 15:53:42","2016-11-06 15:53:42",1
"Hyperledger Fabric","Create ChainPartition type","This maps to a Kafka partition, and is related to the two partitions per chain idea we're exploring for FAB-621. ",Task,Medium,Closed,"2016-11-06 15:50:04","2016-11-06 15:50:04",1
"Hyperledger Fabric","Add channel/subledger support",,Sub-task,Medium,Closed,"2016-11-04 19:41:11","2016-11-04 19:41:11",4
"Hyperledger Fabric","Have self-contained chaincode deployment setup so no manual prep is needed","Tests that need to deploy chaincode need the following setup:  - GOPATH environment variable  - chaincode available at the folder corresponding to $GOPATH/src/<the GO package>    have this be part of the test fixture so contributors don't have to manually set it up locally. set process.env.GOPATH in the code to the test fixture folder just for the test execution.",Sub-task,Medium,Closed,"2016-11-03 18:14:34","2016-11-03 18:14:34",1
"Hyperledger Fabric","Add a gulp task for running tests with coverage reports","gulp test to run the whole test bucket  gulp test-headless to run just the headless tests    both should print a report in the output and generate the HTMLs for the coverage report",Sub-task,Medium,Closed,"2016-11-02 20:44:07","2016-11-02 20:44:07",1
"Hyperledger Fabric","Improve coding styles in headless-tests.js for chaining Promise-based APIs","the current headless-tests.js have a lot of embedded promise-based calls, like below:    functionA()  .then(     function(result) {        // do stuff        functionB()        .then(           function(result) {...});     });    this is defeating the purpose of the design of Promise-based APIs, it should have been chained like below (note the return statement on the call to functionB()):    functionA()  .then(     function(result) {        // do stuff        return functionB();     })  .then(     function(result) {...});  );  ",Sub-task,Medium,Closed,"2016-11-02 01:53:43","2016-11-02 01:53:43",1
"Hyperledger Fabric","Develop an end-2-end test to drive all v1.0 APIs","this is a happy path test that ensures all peer APIs have not regressed or changed, to ensure the SDK API and peer stay in sync",Sub-task,Highest,Closed,"2016-11-01 17:10:04","2016-11-01 17:10:04",2
"Hyperledger Fabric","Test Bootstrapping","An admin would bootstrap the network and would need the following:  * users and certs for each peer  * orderer certs and URL/IP address for the network  * any possible subchannel information if network will be configured with such    The output is:  * the genesis block that contains cert info for all peers in the network  * a hash that is sent to each peer for determining if the genesis block that they receive from the network is genuine.  ",Story,Medium,Closed,"2016-10-28 18:04:31","2016-10-28 18:04:31",3
"Hyperledger Fabric","Add basic chaincode query support","the original Query function has been eliminated from the new design of ChaincodeStubInterface. Instead queries on state values will be performed by sending Proposals.",Sub-task,Medium,Closed,"2016-10-28 05:14:34","2016-10-28 05:14:34",4
"Hyperledger Fabric","As an orderer I have to authenticate the peer that connects to me","The orderer/shim needs to check that the peer's certificate links back to a CA that's referenced in the channel's genesis/reconfiguration block.",Story,Medium,Closed,"2016-10-27 21:01:10","2016-10-27 21:01:10",2
"Hyperledger Fabric","Add support for multiple brokers","Here's a way of going at it:    1. Modify the Docker image so that it spawns three Kafka brokers instead of one.  2. Use a replication factor 3 for created topics.  3. Have the Producers and Deliverers use the Metadata API to find out which broker is the partition leader replica for the given partition, and have the route their requests to it.  4. Verify that everything works.  5. Kill the broker process that owns this replica.  6. Verify that the Producers and Deliverers are using the Metadata API correctly and are rerouting their requests to the new leader.    (That flow may be edited - it is just a suggestion kick things off.)    Let's create linked tasks for the individual work items if necessary, but I would suggest using this story for all related comments, so that we have a single point of reference.",Story,Medium,Closed,"2016-10-27 19:38:22","2016-10-27 19:38:22",4
"Hyperledger Fabric","Enable successful execution of endorser.feature without bootstrap","This will not take into account bootstrapping, but will test the engine flow from the client prespective.",Task,High,Closed,"2016-10-26 19:37:34","2016-10-26 19:37:34",1
"Hyperledger Fabric","Rectify orderer protos with fabric-next protos","The fabric-next protos were recently merged ( https://gerrit.hyperledger.org/r/#/c/1977/2 ) so now all of the temporary protos defined for atomicbroadcast, especially for configuration must be abandoned in favor of the generic set.",Story,Medium,Closed,"2016-10-25 19:16:18","2016-10-25 19:16:18",4
"Hyperledger Fabric","Orderer bootstrap","On orderer bootstrap, read genesis block from file system, parse and save policies, orderer whitelist and peer org certs to appropriate locations then pass control to next orderer process.",Sub-task,Medium,Closed,"2016-10-24 21:19:40","2016-10-24 21:19:40",0
"Hyperledger Fabric","Create per-session buffered channel for broadcast responses","The Recv path should as clear from blocks as possible. An appropriately-sized buffered response channel per connected client and a non-blocking write to it is the way to go.    See https://gerrit.hyperledger.org/r/#/c/1627/5/orderer/kafka/broadcast.go@129 for more details.",Task,Medium,Closed,"2016-10-24 17:39:27","2016-10-24 17:39:27",2
"Hyperledger Fabric","As a Fabric user, I want to know how the Kafka-based ordering service works","We've designed this out in the open, and all the logic is written down in the various JIRA issues that belong to FAB-32, and in #fabric-consensus-dev.    However, it's necessary to wrap everything up in a single document that acts as a point of reference.",Story,Medium,Closed,"2016-10-24 16:10:11","2016-10-24 16:10:11",2
"Hyperledger Fabric","As an application developer I want to implement an application library to offer confidentiality of transaction data.","This task relates to the implementation of the interface defined in previous work item of 830.",Sub-task,Medium,Closed,"2016-10-24 14:00:44","2016-10-24 14:00:44",8
"Hyperledger Fabric","As an application developer I want to define an interface for an application library to offer confidentiality of transaction data.","This relates to the design of an interface of a library offering application level confidentiality.  That would, e.g., enable an application developer to leverage proposals that organize their transient data in such a way, that would enable the chaincode to perform encryption/decryption  without keys being stored to the blockchain.",Sub-task,Medium,Closed,"2016-10-24 13:59:44","2016-10-24 13:59:44",4
"Hyperledger Fabric","As an application I want to have available a library to  help me enforce invocation access control on my chaincodes.",,Story,Medium,Closed,"2016-10-24 13:56:31","2016-10-24 13:56:31",8
"Hyperledger Fabric","As an application/infrastructure developer I want to design a generic membership service interface","This item reflects the work needed to design an interface for membership services operations (issuing/managing certificates, and authentication mechanisms using those certificates) in a way that that interface does not depend on the exact implementation/cryptographic primitives that the membership service uses.   This interface is to be integrated to core operations of the fabric, such that a fabric deployer who wishes to substitute only membership service component of the system, is able to do so without affecting the code of fabric core/transaction processing.   Wee need to define one interface used by the infrastructure (verification MSP interface) and one for the client to construct transactions (retrieving the corresponding certificates), and signing with its secret key.  ",Story,Medium,Closed,"2016-10-24 13:52:14","2016-10-24 13:52:14",8
"Hyperledger Fabric","Create couchdb database automatically for main system ledger","The assumption is that all chaincode will run in one CouchDB database for the system ledger, and there will be separate databases for each subledger.",Story,High,Closed,"2016-10-24 13:41:06","2016-10-24 13:41:06",2
"Hyperledger Fabric","As an infrastructure developer i want to implement ACLs on (channel) events","Implement the technique designed in FAB-637 for registration (access control enforcement) to a channel's events. Extend that implementation to have a aper-channel access policy/check.",Task,Medium,Closed,"2016-10-24 13:38:41","2016-10-24 13:38:41",8
"Hyperledger Fabric","As an infrastructure developer i want to build a default membership service provider for peer functionality","On one hand, here we would need to refactor the code associated to membership service functionalities, i.e., code for signing w.r.t. a certificate, certificate signature verification to export the interface agreed within FAB-829. This would substitute the default membership service provider for fabric.  Another task associated to this story is that throughout the implementation of this default IDP we would need to make sure that crypto calls go through our BC-CSP that was implemented in FAB-355.",Task,Medium,Closed,"2016-10-24 12:51:29","2016-10-24 12:51:29",4
"Hyperledger Fabric","Size broadcaster's batchChan appropriately","See https://gerrit.hyperledger.org/r/#/c/1627/3/orderer/kafka/broadcast.go@50 and [~<USER>'s comment for details.    batchChan is the buffered channel where the broadcaster part of the Kafka shim holds incoming messages until it's time to cut a new block. In the current solo-like implementation, setting the number of elements of this buffer equal to the number of messages a block is expected to have is short-sighted.    We are now moving towards a model where the shim just relays each message to the broker as it receives it, so the original problem goes away, but we should still come up with an appropriate capacity for this.    Do we expose this as a configuration parameter with a sensible default and call it a day? (And what makes for a sensible default?)",Task,Medium,Closed,"2016-10-22 17:51:13","2016-10-22 17:51:13",0
"Hyperledger Fabric","As an ordering service user I want to have multi-chain support","I want to be able to send a ConfigurationEnvelope that calls for the creation of a new ChainID, and have a new chain created. I then want to be able to then broadcast and deliver on that chain.    This story will NOT cover the following: The logic that turns a new-chain ConfigurationEnvelope and creates an appropriate genesis block for that new chain. The code that will be delivered with this story will keep using the same genesis block (the one returned by the static bootstrapper).",Story,Medium,Closed,"2016-10-22 06:28:50","2016-10-22 06:28:50",12
"Hyperledger Fabric","Push CouchDB prototype into fabric",,Sub-task,Medium,Closed,"2016-10-21 22:04:26","2016-10-21 22:04:26",2
"Hyperledger Fabric","Update CI jobs to support the new unit test infrastructure","Once FAB-776 is complete, need to update the CI job to run the new unit tests that require setting up the target network (with docker)",Sub-task,Medium,Closed,"2016-10-21 14:34:49","2016-10-21 14:34:49",2
"Hyperledger Fabric","Abstract out common Kafka/Solo components","The ordering service has multiple ordering providers, including kafka and solo.  Because each service must implement the same ordering api, there are significant functional duplication between the codebases.    This story is intended to cover the work of identifying the common components, abstracting them out, and ensuring that both handle configuration and reconfiguration as well as transaction filtering the same way.",Story,Medium,Closed,"2016-10-20 19:53:43","2016-10-20 19:53:43",4
"Hyperledger Fabric","As a fabric developer, I want to understand CouchDB security implications as a ledger state database",,Story,High,Closed,"2016-10-20 17:57:42","2016-10-20 17:57:42",8
"Hyperledger Fabric","As a fabric developer, I want to understand ledger LevelDB performance",,Story,High,Closed,"2016-10-20 17:55:49","2016-10-20 17:55:49",4
"Hyperledger Fabric","As a fabric developer, I want to understand CouchDB performance as a ledger state database","Initial assessment is complete.  Senthil please attach a community-friendly copy of the performance assessment to this work item.",Story,High,Closed,"2016-10-20 17:54:56","2016-10-20 17:54:56",8
"Hyperledger Fabric","As a fabric developer, I want to replace RocksDB with another key/value datastore","RocksDB has a patent infringement license in it from Facebook. The legal team is therefore not comfortable with using it. For details read: https://github.com/facebook/rocksdb/blob/master/PATENTS    The alternatives include  1. LevelDB (https://github.com/google/leveldb) with a go wrapper (https://github.com/jmhodges/levigo),  2. *goleveldb* (https://github.com/syndtr/goleveldb) - a porting of leveldb in golang  3. BoltDB (https://github.com/boltdb/bolt)    BoltDB is suitable for read heavy workloads (e.g., LDAP) but has a relatively poor performance for read-write workloads.  Of the other two options, *goleveldb* is chosen because it is implemented in golang and hence easy to intergate and maintain.  In addition, as a precedent, ethereum go implementation also uses this package (https://github.com/ethereum/go-ethereum/blob/master/ethdb/database.go)",Story,High,Closed,"2016-10-20 17:51:40","2016-10-20 17:51:40",8
"Hyperledger Fabric","As a fabric deployer, I want a CouchDB docker image that can be deployed with a fabric network",,Story,High,Closed,"2016-10-20 17:49:21","2016-10-20 17:49:21",4
"Hyperledger Fabric","As a fabric developer, I want to use ledger CouchDB in the end-to-end endorser/orderer/committer skeleton",,Story,High,Closed,"2016-10-20 17:44:09","2016-10-20 17:44:09",8
"Hyperledger Fabric","Pluggable state database - Design for transactional behavior","Pluggable state database - Design for transactional behavior",Task,High,Closed,"2016-10-20 17:20:57","2016-10-20 17:20:57",4
"Hyperledger Fabric","Remove sdk/node folder from fabric project in master","[~<USER> has done the work to merge all subsequent changes to v0.6 and master in the original location (fabric/sdk/node) to the new project (fabric-sdk-node), tracked in FAB-659. so there's no need to keep the old code around in fabric.    [~<USER> [~<USER> want to make sure you guys are aware of this planned action. Hoping to do it asap. Would there be any concerns w.r.t the build steps and CI jobs? we'll for sure clean up the make file as part of this.",Sub-task,Medium,Closed,"2016-10-20 17:05:49","2016-10-20 17:05:49",2
"Hyperledger Fabric","Update readme for the fabric-sdk-node repo to be more contributor friendly","should prominently include steps to build, set up test environment and run tests.",Sub-task,Medium,Closed,"2016-10-20 15:57:17","2016-10-20 15:57:17",1
"Hyperledger Fabric","Orderer GRPC API","Define a GRPC API for client to submit a transaction to Orderer (ie broadcast and deliver).     This is currently in ab.proto, which we need to beef up the description on error conditions.",Story,High,Closed,"2016-10-19 23:11:46","2016-10-19 23:11:46",1
"Hyperledger Fabric","Add code coverage to CI jobs","best option with node.js is using Istanbul.    it doesn't require any code changes. As long as the test cases are written, Istanbul can automatically insert itself with runtime instrumentation.    Basic procedures to enable this on CI jobs:  - install istanbul globally  - istanbul cover test/unit/headless-tests.js  - print a link to the coverage report html (in coverage/lcov-report/index.html)    In addition, Jenkins has a code coverage plugin that supports Istanbul reports, plus keeping track of coverage trends and generates charts",Sub-task,Medium,Closed,"2016-10-18 17:48:42","2016-10-18 17:48:42",2
"Hyperledger Fabric","Integrate configuration manager into orderer startup",,Sub-task,Medium,Closed,"2016-10-18 15:49:47","2016-10-18 15:49:47",1
"Hyperledger Fabric","Create and define gossiping node meta object","Once new node appears in the network it has to complete the state based on the information of the ledger height in other nodes. This information is disseminated during gossip keep alive mechanism, e.g. each node transfer its meta-state which should include information about ledger.    Need to provide an ability to store relevant info within nodes, serialize and de-serialize this information.",Sub-task,Medium,Closed,"2016-10-18 15:00:15","2016-10-18 15:00:15",1
"Hyperledger Fabric","Pluggable state database - Install CouchDB into Vagrant dev env as a docker image","Pluggable state database - Install CouchDB into Vagrant dev env  ",Task,High,Closed,"2016-10-17 18:01:54","2016-10-17 18:01:54",4
"Hyperledger Fabric","Pluggable state database - Initial implemenation for CouchDB","Pluggable state database - Initial implemenation for CouchDB as state database.",Task,High,Closed,"2016-10-17 18:00:07","2016-10-17 18:00:07",4
"Hyperledger Fabric","Create chain config subsystem to manager configuration data","There is a need to embed initial configuration in the genesis block of the chain.  This information must further be able to be conditionally modified in the future.  This task is to define the necessary proto messages and write a configuration subsystem to store and modify chain configuration.",Sub-task,Medium,Closed,"2016-10-16 05:05:16","2016-10-16 05:05:16",1
"Hyperledger Fabric","Investigate certificate pinning for gRPC TLS","In fabric 1.0 orderer nodes will identified via self-signed certificates. These certificates will not be verifiable via a known root certificate chain. The individual certificates will be made available to the various fabric / orderer network nodes via transactions (in blocks) on a block chain.  If these same certificates can be used to initiate the TLS connection between the various nodes that might prove to be enough to 'identify' the nodes.",Task,Medium,Closed,"2016-10-13 18:37:12","2016-10-13 18:37:12",4
"Hyperledger Fabric","Create orderer common components dir","The complexity with introducing pluggable pieces for filtering and validation into ordering is making the 'throw everything into the orderer directory' policy not make sense.  The directory structure should be re-arranged.",Sub-task,Medium,Closed,"2016-10-13 18:12:59","2016-10-13 18:12:59",1
"Hyperledger Fabric","Create a policy manager","With the ability to specify policy in FAB-704 it is necessary for the orderer to track what policies are currently in effect and be able to evaluate whether a policy is satisfied by a given transaction.    Therefore, a framework for updating and evaluating policies is necessary.",Sub-task,Medium,Closed,"2016-10-13 17:03:54","2016-10-13 17:03:54",2
"Hyperledger Fabric","Create signature validation DSL for use by filtering framework and later more broad use","At a high level, the initial configuration defines things like Only allow clients who have a certificate which is signed by one of these 6 parties, but there is no obvious way to express this in a datastructure.  Especially as more complicated signature schemes must be specified such as It must be signed by the network owner, and, it must also have 4 of the 7 stake holders sign off as well the need for a domain specific language arises to express these concepts.    This should be defined in protobuf, as it is how we store and marshal things on the blockchain today.",Sub-task,Medium,Closed,"2016-10-13 16:51:35","2016-10-13 16:51:35",2
"Hyperledger Fabric","Dynamic set of peers.","Dissemination layer has to provide an ability of dynamic addition for new peer members, it has to be able to recover from network partition and congestion. Moreover it has to preserve node state integrity.    New coming or lagging peers will use the capabilities of this module to synchronize their state from the neighbor peers. ",Story,Medium,Closed,"2016-10-13 15:34:27","2016-10-13 15:34:27",8
"Hyperledger Fabric","Connections between shims and Kafka cluster should be authenticated","As of 0.9, Kafka supports TLS for client/broker and inter-broker communication.    We need to enable it, and also make sure that when a shim or broker is added/removed, the ACLs are updated accordingly.    There are no APIs provided by Kafka for this, so we will have to resort to executing scripts.    https://cwiki.apache.org/confluence/display/KAFKA/Kafka+Authorization+Command+Line+Interface  http://www.confluent.io/blog/apache-kafka-security-authorization-authentication-encryption/    Some more context here: https://hyperledgerproject.slack.com/archives/fabric-consensus-dev/p1477597906002876    Feel free to break this story into tasks, but let's use this as a point of reference for comments and discussion.",Story,High,Closed,"2016-10-13 15:04:46","2016-10-13 15:04:46",8
"Hyperledger Fabric","Make genesis block configurable ","The orderer rawledgers have a static genesis block hardcoded in them today.  Although we will likely want to continue to use a static block for testing, hard coding it should be centralized and not distributed throughout the codebase.",Sub-task,Medium,Closed,"2016-10-12 19:09:37","2016-10-12 19:09:37",1
"Hyperledger Fabric","As an orderer administrator, I can generate a genesis block hash and initial connection settings to the orderer nodes, so that I can provide them to a fabric administrator.",,Story,Medium,Closed,"2016-10-11 16:07:54","2016-10-11 16:07:54",0
"Hyperledger Fabric","As an orderer administrator, I can startup new orderer nodes using a genesis block, so that I can bootstrap my orderer network.","given a genesis block as defined in fab-665,  start an orderer node",Story,Medium,Closed,"2016-10-11 16:07:54","2016-10-11 16:07:54",2
"Hyperledger Fabric","As an orderer administrator, I can inspect a genesis block, so that I may deem it satisfactory.","on orderer bootstrap, verify that inputted genesis block is valid",Story,Medium,Closed,"2016-10-11 16:07:54","2016-10-11 16:07:54",1
"Hyperledger Fabric","As an orderer I want to retrieve the genesis block and join the network","Implement bootstrap startup procedure that accepts genesis block file containing configuration for orderer. Make sure the data is organized as specified in FAB-359.",Task,Medium,Closed,"2016-10-11 16:07:53","2016-10-11 16:07:53",2
"Hyperledger Fabric","As a bootstrap administrator, I want to be able to generate a genesis block","We need a tool (CLI) that accepts the necessary inputs and generate a file, which will be used by orderers and member peers on start-up.",Story,Medium,Closed,"2016-10-11 16:07:53","2016-10-11 16:07:53",4
"Hyperledger Fabric","As an orderer administrator, I can provide the bootstrap administrator with the configuration of the orderer nodes I administer, so that the bootstrap administrator can include the information in a genesis block.","Decide on who should decide the number of orderer nodes and how that information is distributed to the nodes",Story,Medium,Closed,"2016-10-11 16:07:52","2016-10-11 16:07:52",1
"Hyperledger Fabric","As a bootstrap administrator, I can gather the signer certificates of one or more organizations running a common fabric network, so that I can generate a genesis block.",,Story,Medium,Closed,"2016-10-11 16:07:52","2016-10-11 16:07:52",0
"Hyperledger Fabric","As a fabric administrator, I can provide the bootstrap administrator with my peer network's signer certificates, so that the bootstrap administrator can included the information in a genesis block.","Use this story to work with security team on how to generate the CA certs and how to distribute to the bootstrap admin",Story,Medium,Closed,"2016-10-11 16:07:51","2016-10-11 16:07:51",0
"Hyperledger Fabric","As a fabric administrator, I can gather my fabric network signer certificates, so that I may provide them to a bootstrap admin.",,Story,Medium,Closed,"2016-10-11 16:07:51","2016-10-11 16:07:51",1
"Hyperledger Fabric","Merge master branch's bug fixes and tests into fabric-sdk-node","the new repository fabric-sdk-node was based on a pre-v0.6 version of the master branch. The master branch has since been further enhanced with bug fixes. We want to bring those into the new repo where make sense.    [~<USER> has already started working on migrating over the event hub feature into the new repo, so this effort doesn't need to take into account any code related to event hub.",Sub-task,Medium,Closed,"2016-10-11 15:50:10","2016-10-11 15:50:10",8
"Hyperledger Fabric","As a fabric developer I want to document the ordering-service channel ACL design",,Story,Medium,Closed,"2016-10-10 09:23:25","2016-10-10 09:23:25",4
"Hyperledger Fabric","Create a hash-chain for the Kafka orderer","Remember that our goal is to make this Kafka orderer layer that now stands between the client and the broker as thin as possible. We want to let Kafka do most of the work, since it's a well-tested and performant solution and we don't want to replicate any of its functionality.    The Kafka orderer does two things:  # It batches transactions into blocks (which we should stop doing by the way, because Kafka can do it for us), and  # It creates a hash-chain between the blocks    In this story, we should explore the various ways with which we can create hash-chain with Kafka. Our goal is to find (a) the one that performs best (i.e. is the fastest), and (b) uses as less custom code as possible.    Suggestions:  # [~<USER> suggested that it may be worth looking into Kafka Connect.  # I haven't studied it carefully but I am wondering whether the new Kafka Streams functionality can get us there.  # Finally, there is always the option of creating a hash-chain via checkpoint messages, an idea that was first suggested by Chet Murthy: every K messages received, each client broadcasts a checkpoint message via the orderer that is the hash of this concatenation: (previous checkpoint hash + K most recent messages)",Story,Medium,Closed,"2016-10-06 21:42:12","2016-10-06 21:42:12",12
"Hyperledger Fabric","Add error paths to endorser-tests.js","In the initial changeset there's only happy path. Need to add more error paths like what's done in ca-tests.js.",Sub-task,Medium,Closed,"2016-10-06 15:40:48","2016-10-06 15:40:48",2
"Hyperledger Fabric","Add headless unit tests for Peer.js and Member.js","So that each function are tested for handling good and bad params, etc.",Sub-task,Medium,Closed,"2016-10-06 15:38:33","2016-10-06 15:38:33",2
"Hyperledger Fabric","As a fabric developer I want to use the fabric crypto library throughout the fabric peer and membership service code in 0.6 branch.","Here we would need to update the fabric peer and memebrship service crypto operations with code that leverages the crypto API defined in FAB-354.  We aim to do this for the *0.6 branch*, and (with other issues/tasks) extend this to the *master* using FAB-580-582 and FAB-744. Smaller chunk work-items involve:   A) as long as the signing capabilities are supported by a software provider offering the API defined in FAB-354 (part of FAB-355), we refactor peer (golang) code (NVP and VP) to sign using that library (and its APIs   B) as long as the signing capabilities are supported by a software provider offering the API defined in FAB-354 (part of FAB-355), we refactor membership service server code to sign using that library (and its APIs   C) as long as ECIES encryption capabilities are supported by a software provider offering the API defined in FAB-354 (part of FAB-355), we refactor peer (golang) code (NVP and VP) to decrypt transactions using that library (and its APIs)   D) repeat the process for the master branch  ",Task,Medium,Closed,"2016-10-06 09:52:22","2016-10-06 09:52:22",6
"Hyperledger Fabric","Document auditability capabilities within fabric-next","This would be an attempt to list potential auditing threat models and in what ways fabric-next protocol accommodate such models.     This associates to most components of the system, endorsers, committing peers, orderers, and more importantly, clients.",Task,Medium,Closed,"2016-10-06 09:43:58","2016-10-06 09:43:58",4
"Hyperledger Fabric","Create headless crypto unit tests for node.js SDK standalone",,Sub-task,Medium,Closed,"2016-10-05 20:07:00","2016-10-05 20:07:00",4
"Hyperledger Fabric","Ledger VerifyChain: As a consumer of Ledger APIs, I want to verify the integrity of the blockchain"," //VerifyChain will verify the integrity of the blockchain. This is accomplished   // by ensuring that the previous block hash stored in each block matches   // the actual hash of the previous block in the chain. The return value is the   // block number of lowest block in the range which can be verified as valid.    Also we need to verify that state database is correct, or have an option to rebuild it to ensure it is correct.  ",Story,High,Closed,"2016-10-05 16:14:43","2016-10-05 16:14:43",4
"Hyperledger Fabric","sbft: detect that we are behind and need state transfer","From the code comment after processing the backlog:    We arrived here because either all is fine, we're with the pack.  Or we have messages in the backlog because we're connected asymmetrically, and a close replica already started talking about the next batch while we're still waiting for rounds to arrive for our current batch.  That's still fine.    We might also be here because we lost connectivity, and we either missed some messages, or our connection is bad and we should reconnect to get a working connection going again.     If a noFaultyQuorum (-1, because we're not faulty, just were disconnected) is backlogged, we know that we need to perform a state transfer.  Of course, f of these might be byzantine, and the remaining f that are not backlogged will allow us to get unstuck.  To check against that, we need to only consider backlogged replicas of which we have a hello message that talks about a future Seq.     We need to pick the highest Seq of all the hello messages we received, perform a state transfer to that Batch, and discard all backlogged messages that refer to a lower Seq.    Do we need to detect that a connection is stuck and we should reconnect?  ",Story,Medium,Closed,"2016-10-05 11:51:59","2016-10-05 11:51:59",8
"Hyperledger Fabric","sbft: Prevent DoS by limiting the number of messages per replica","If the backlog limit is exceeded, discard all messages with Seq before the replica's hello message (we can, because we can play forward to this batch via state transfer).  If there is no hello message, we must be really slow or the replica must be byzantine.  In this case we probably should re-establish the connection.    After the connection has been re-established, we will receive a hello, and the following messages will trigger the pruning of old messages.  If this pruning lead us not to make progress, the backlog processing algorithm as lined out below will take care of starting a state transfer, using the hello message we received on reconnect.  ",Story,Medium,Closed,"2016-10-05 11:48:37","2016-10-05 11:48:37",4
"Hyperledger Fabric","Refactor LevelDB state database for new state database plugin model","Ensure common code such as endorser simulation can be shared, and the state database interactions can be plugged in to support other databases.    This work item focus is on LevelDB refactor.    Look into Go 1.8's plugin system:  https://tip.golang.org/pkg/plugin/",Sub-task,Medium,Closed,"2016-10-05 11:32:46","2016-10-05 11:32:46",4
"Hyperledger Fabric","Ledger versioning scheme: I want to use the block/transaction height as a variable's version, instead of an incrementing version number, so that I have traceability between state data and transaction data","Ledger versioning scheme: I want to use the block/transaction height as a variable's version, instead of an incrementing version number, so that I have traceability between state data and transaction data",Story,High,Closed,"2016-10-05 11:22:45","2016-10-05 11:22:45",2
"Hyperledger Fabric","As an endorser performing simulation, I want the state database to always be in sync with the blockchain ledger on the file system","ledgernext was initially delivered in sprint1 to quickly unblock dependent components, in this task the simulation and state management code will be hardened, for example to ensure the state index is always consistent with the blockchain ledger.",Story,High,Closed,"2016-10-05 11:06:57","2016-10-05 11:06:57",8
"Hyperledger Fabric","Add orderer configuration broadcast filter",,Sub-task,Medium,Closed,"2016-10-04 19:24:47","2016-10-04 19:24:47",1
"Hyperledger Fabric","Add client validation broadcast filter",,Sub-task,Medium,Closed,"2016-10-04 19:24:25","2016-10-04 19:24:25",1
"Hyperledger Fabric","Add broadcast filter framework",,Sub-task,Medium,Closed,"2016-10-04 19:23:46","2016-10-04 19:23:46",1
"Hyperledger Fabric","New unit tests infrastructure - part I","When i run any unit tests, including both the headless and those that require a target network, I should just be doing npm test or node <path to test JS>, without relying on any external shell scripts.    The first step should be building a local target based on docker images.",Story,High,Closed,"2016-10-03 19:51:46","2016-10-03 19:51:46",4
"Hyperledger Fabric","As a fabric developer working on endorser logic I want to do all the required security checks on a client proposal","This is in accordance to FAB-351, and FAB-489.",Story,Medium,Closed,"2016-10-02 13:38:58","2016-10-02 13:38:58",8
"Hyperledger Fabric","Behave execution in remote systems",,Story,Medium,Closed,"2016-09-30 20:42:40","2016-09-30 20:42:40",4
"Hyperledger Fabric","Behave tests",,Sub-task,Medium,Closed,"2016-09-30 17:53:50","2016-09-30 17:53:50",1
"Hyperledger Fabric","Performance tests (statistics, python)",,Sub-task,Medium,Closed,"2016-09-30 17:53:31","2016-09-30 17:53:31",1
"Hyperledger Fabric","Implement crypto in python SDK","Follow SDK spec and refer to nodeJS SDK implementation.",Story,Medium,Closed,"2016-09-30 03:34:29","2016-09-30 03:34:29",5
"Hyperledger Fabric","Add reconnection logic","If the Kafka brokers are not up yet, the orderer should attempt to reconnect to them every X seconds for a period of Y seconds, instead of panicking right away.    This means there's no need for sleep 5s hacks when bringing up a network for BDD tests via Docker Compose.",Task,Medium,Closed,"2016-09-29 21:52:04","2016-09-29 21:52:04",1
"Hyperledger Fabric","escc and vscc for end-to-end skeleton","Create the first set of default endorser/validator system chaincode.    To start , these scc  are no-ops just so that we can use them in the end-toend skeleton.    Future tasks will add the endorser signature and the actual validate/invalidate methods",Sub-task,Medium,Closed,"2016-09-29 20:50:15","2016-09-29 20:50:15",4
"Hyperledger Fabric","Each solo orderer client should have a separate flow control window","The QueueSize configuration option is being applied across all orderer clients. Change this to apply on a per-client basis.",Task,Medium,Closed,"2016-09-28 15:14:51","2016-09-28 15:14:51",2
"Hyperledger Fabric","Add logging utility to hide specific logging library","Develop a standard logging util that in turn uses one of the popular JS logging libraries. Likely going to be winston.    The logging utility would expose standard configurable logging levels and hide the underlying logging library, so that the SDK consumers can set a logger for the SDK to use in order to have consistent logs format across the application (inside the SDK and outside).",Sub-task,Medium,Closed,"2016-09-28 14:12:33","2016-09-28 14:12:33",4
"Hyperledger Fabric","GO SDK changes to allow running tests in pre-existing remote networks","Some of our tests for consensus and ledger stress tests are written in GO, and use a GO SDK which creates a local network, given networkcredentials file. This task is for implementing changes to the GO SDK functions that will allow the option to run the same tests in non-local (external) networks that may even already exist.",Task,High,Closed,"2016-09-27 22:57:26","2016-09-27 22:57:26",4
"Hyperledger Fabric","Create mechanism for orderer to interpet the genesis block and configuration transactions","The orderer must be able to parse the content of a configuration transaction, whether this means pulling in the system chaincode execution environment from the peer, or more manually reading raw postimage data from the transaction itself.  The complexity vs reuse will need to be carefully weighed for this story.",Story,Medium,Closed,"2016-09-27 21:57:31","2016-09-27 21:57:31",5
"Hyperledger Fabric","Create mechanism for orderer service to selectively process configuration transactions","It is important that the ordering service not accept arbitrary configuration transactions, especially as the peer will not require any endorsement of these transactions initially.  Therefore, the ordering service should inspect and filter out these configuration changes, with a hook to allow them to be processed later, likely through validation of some endorsement-like process.",Story,Medium,Closed,"2016-09-27 21:55:29","2016-09-27 21:55:29",4
"Hyperledger Fabric","Create system chaincode at the peer to handle configuration changes","When the peer receives a configuration transaction, as defined in FAB-496, it needs to call the Configuration System Chaincode (CSCC) which performs the following:  # map the changes into the correct read-write-set for the ledger to store  # process the configuration changes if applicable;  ex, removing a member CA from the chain, calling gossip  # commit the transaction to ledger    CSCC will provide the following functions:  # process join channel for the peer to start receiving transactions on the specified channel  # process transaction on commit  # process queries to return configuration data on channel (status, members, crypto)    For now, we will not require any endorsement of the transaction though this may be added in the future.  ",Story,Medium,Closed,"2016-09-27 21:51:24","2016-09-27 21:51:24",3
"Hyperledger Fabric","Generate initial configuration transaction for orderer genesis block","The orderer needs to be able to take its initial configuration and deterministically generate a configuration transaction which all orderers will agree on.  This transaction should be well formed, and must be able to be interpreted by both the ordering service and the peer.",Story,Medium,Closed,"2016-09-27 21:49:02","2016-09-27 21:49:02",5
"Hyperledger Fabric","Embed orderer configuration in rawledger","The orderer configuration needs to be embedded within the raw ledger.    This is for two reasons:    1. The orderer service needs to be able to convey initial configuration and configuration changes to the peer service so that the peer knows how to properly validate the raw ledger being returned (this may be different per orderer implementation, and may as simple as verifying a public key, or as complicated as a PBFT f+1 out of N signatures or connections)  2. The orderer service must agree to an initial configuration as without a common initial configuration (and common points of time for changing the configuration) the correctness of the orderer service may not be guaranteed.    This will require coordination between the chaincode/ledger peer side for applying and interpreting the configuration changes, as well as the orderer side for generating, and agreeing upon such changes..",Story,Medium,Closed,"2016-09-27 21:44:56","2016-09-27 21:44:56",21
"Hyperledger Fabric","leverage GO obcsdk to use node.js API instead of REST","Our GO obcsdk is used by a set of tests written in GO for consensus acceptance and regression, ledger stress tests, concurrency, and longrun testing. To talk to the Peers, client threads use REST calls. To leverage all these tests in v1.0 and beyond using node.js (especially needed if REST is deprecated), we must:  # Decouple the REST functions from the GO application layer, and create a well-defined API.  # Implement the node.js SDK communication interface methods, to perform the same functions as the existing REST functions.  # Provide a test environment variable for the GO application tests to choose either REST or node.js. ",Story,Medium,Closed,"2016-09-27 20:10:00","2016-09-27 20:10:00",8
"Hyperledger Fabric","Protobufs reflecting the next endorsement/consentor architecture ",,Story,Highest,Closed,"2016-09-27 18:05:27","2016-09-27 18:05:27",4
"Hyperledger Fabric","Document confidentiality features of fabric and changes to the next architecture",,Story,Medium,Closed,"2016-09-27 18:03:02","2016-09-27 18:03:02",2
"Hyperledger Fabric","Document how application-level confidentiality could work",,Sub-task,Medium,Closed,"2016-09-27 17:59:19","2016-09-27 17:59:19",1
"Hyperledger Fabric","sbft: exchange peer replica state on new connection","When a connection gets (re) established, replicas exchange their latest chain state.  This allows a restarted/reconnecting replica to quickly catch up to the network without having to wait for new checkpoints that finally trigger state transfer.    From the code comment:    A reconnecting replica can play forward its blockchain to the batch listed in the hello message.  However, the currently in-flight batch will not be reflected in the Hello message, nor will all messages be present to actually commit the in-flight batch at the reconnecting replica.    Therefore we also send the most recent (pre)prepare, commit, checkpoint so that the reconnecting replica can catch up on the in-flight batch.  ",Story,Medium,Closed,"2016-09-27 14:04:16","2016-09-27 14:04:16",4
"Hyperledger Fabric","generic check for correct requests","The consensus network should not add garbage data to the batches it produces.  Especially under byzantine assumptions, it is possible that byzantine nodes (client, primary) introduce invalid data into the batches.  To protect against this, requests proposed by a leader need to be validated for a correct signature from an authorized client.  This way a leader (or unauthorized client) can not add invalid requests.  This can be implemented as a generic component that can be shared by different consensus implementations.  In the case of bft, replicas check the batch preprepared by the primary and perform a view change when requests are invalid.  This component would be used by FAB-474 to filter requests before they get added to the fresh pool.",Story,Medium,Closed,"2016-09-27 13:23:06","2016-09-27 13:23:06",8
"Hyperledger Fabric","generic censorship prevention and duplicate request purge for BFT consensus","We want to prevent the primary of sBFT (but really any replica in any BFT atomic broadcast) to censor requests (i.e., drop individual requests).      Proposal: Per discussion with [~<USER>, this could be addressed by a generic component (not be part of sbft core, nor specific to sbft), which keeps track of new requests (fresh), in-flight requests (pending, only at primary), and recently completed requests.  Timestamped entries are serviced infrequently (several second scale), and fresh requests will be brought to the attention of the remaining network, including the primary.  When a second, longer, timeout expires, the component signals to the atomic broadcast implementation that the leader should be changed.    Every time the atomic broadcast implementation observes a change in leader, this is communicated to the component and timeouts are adjusted to give the new leader time to act.    The leader also uses the registry of fresh requests to assemble a new batch.    This sounds deceivingly simple and probably will turn out to be more complicated than expected.",Story,Medium,Closed,"2016-09-27 13:14:27","2016-09-27 13:14:27",8
"Hyperledger Fabric","sbft: create standalone consensus peer","create executable that will act as atomic broadcast client and use sbft as backend",Story,Medium,Closed,"2016-09-27 12:56:55","2016-09-27 12:56:55",8
"Hyperledger Fabric","Make logging level configurable for solo orderer and config package","I think a command-line flag (as we do in the Kafka orderer) will do to begin with, but we probably want to add this to the YAML file as well.",Task,Low,Closed,"2016-09-27 05:05:08","2016-09-27 05:05:08",2
"Hyperledger Fabric","Ensure multiple orderer shims can operate in parallel",,Story,Medium,Closed,"2016-09-27 01:37:51","2016-09-27 01:37:51",0
"Hyperledger Fabric","Add support MaxWindowSize and QueueSize","MaxWindowSize sets an upper bound on a client's requested window, and QueueSize sets an upper bound on the maximum number of messages a client may have pending. These are not necessary to have but they are good features and they align the Kafka orderer with the Solo one.",Task,Medium,Closed,"2016-09-27 01:31:08","2016-09-27 01:31:08",2
"Hyperledger Fabric","Add support for orderer/config package","Switch over the Kafka orderer to the config package introduced in FAB-386: https://gerrit.hyperledger.org/r/1153",Task,Medium,Closed,"2016-09-27 01:23:13","2016-09-27 01:23:13",2
"Hyperledger Fabric","Harden ledgernext block storage implementation","ledgernext was initially delivered in sprint1 to quickly unblock dependent components, in this task the block storage code will be hardened.",Task,Highest,Closed,"2016-09-26 08:34:29","2016-09-26 08:34:29",4
"Hyperledger Fabric","Ledger consistent simulation (RocksDB snapshot option): As a consumer or ledger APIs (endorser), I want to perform proposal simulation using a consistent view of ledger state, by optionally using RocksDB snapshots","Consistent reads has been implemented by using locks between readers and writers.  This task would implement consistent reads by using RocksDB snapshots, so that reads and writes can occur in parallel.  We then need to compare the two options and determine which one is better, e.g. from a performance perspective.",Story,Medium,Closed,"2016-09-26 08:25:31","2016-09-26 08:25:31",4
"Hyperledger Fabric","Ledger storage of large values: For large key values, I don't want to duplicate the value in the state database, I want to point to the ledger block file instead, so that I don't incur a performance penalty when writing to the state database","This would also help in scenarios where you don't want to trust state database, and prefer to get the data directly from the block storage (could do it for all reads/writes and not just for large data).    If we were to do this, state reads would be less efficient, and rich query would not be possible (on couchdb). These may or may not be import considerations, depending on the specific use case.",Story,Medium,Closed,"2016-09-26 08:21:25","2016-09-26 08:21:25",4
"Hyperledger Fabric","Prototype pluggable state database","Initial prototype to use an external state database will use CouchDB.",Task,Medium,Closed,"2016-09-26 08:11:10","2016-09-26 08:11:10",4
"Hyperledger Fabric","Create orderer bootstrap feature","Create a `.feature` file describing the behavior of bootstrapping orderers. ",Task,Medium,Closed,"2016-09-23 15:18:51","2016-09-23 15:18:51",4
"Hyperledger Fabric","Decide on orderer bootstrap design","From zrl/ykt/rtp discussions this week, we decided that   * the number of nodes in an orderer service instance is static. We will not dynamically add/remove nodes (at least for the short term. Discussion on how to dynamically add/remove nodes will continue and we will look to add this feature in a future hyperledger release.)  * Orderer nodes will startup based on a whitelist listing all participating nodes ",Task,Medium,Closed,"2016-09-21 20:34:53","2016-09-21 20:34:53",16
"Hyperledger Fabric","Enhance atomicbroadcast API to support channels","In order to support delivering batches to only a subset of peers, the atomicbroadcast API must be enhanced to allow channel creation, channel membership polling or notifications, and broadcast or delivery to one or more channels.    This will require modifications to the `atomicbroadcast/ab.proto`.  This will cascade into modification of solo to support the new API.",Story,Medium,Closed,"2016-09-21 18:40:01","2016-09-21 18:40:01",8
"Hyperledger Fabric","Update/review the part of endorsers that does the crypto processing of a received proposal","This issue relates    - review the code that does the parsing of a proposal to better understand it   - ensure that all the needed security checks are in place   - write  (refactoring from old code) the code to provide endorsements as required by the fabric-next protocol.  ",Story,High,Closed,"2016-09-15 08:52:45","2016-09-15 08:52:45",4
"Hyperledger Fabric","Add robust configuration mechanism for the orderer package","The orderer service uses piecemeal configuration using environment variables today.  This should be done using Viper, but using the newer API which allows error on extraneous variables.    In the event that the newer version of Viper is not available, the similar but older version of the call can be used temporarily.    This should be re-usable across Solo, Kafka, and the RawLedger implementations.",Story,Medium,Closed,"2016-09-13 15:44:21","2016-09-13 15:44:21",2
"Hyperledger Fabric","Standardize block format between raw ledger and validated ledger","The orderer work for consensus requires a raw ledger which stores blocks, and the peer work for ledger team also requires a solution which stores blocks.    Because of the commonality, a common block format needs to be decided upon that can satisfy both the needs of the raw ledger, and the validated ledger.",Task,Medium,Closed,"2016-09-13 15:03:17","2016-09-13 15:03:17",4
"Hyperledger Fabric","Verify manual state transfer works","As we discussed over the weekend, following Gari's suggestion. Needed in case things go terribly bad.",Task,Highest,Closed,"2016-09-13 15:00:42","2016-09-13 15:00:42",1
"Hyperledger Fabric","Write Go-based BDD tests for Kafka orderer","These will be written using the GoConvey framework, cause I want to switch over from the Python-based behave framework that we use know. (I know Go better than I know Python.) I know Jeff's already working on porting some of the BDD tests to Go as well.",Task,Lowest,Closed,"2016-09-13 07:07:31","2016-09-13 07:07:31",4
"Hyperledger Fabric","Write unit tests for Kafka orderer",,Task,Medium,Closed,"2016-09-13 07:07:06","2016-09-13 07:07:06",4
"Hyperledger Fabric","Build the Kafka orderer prototype",,Task,Medium,Closed,"2016-09-13 07:06:28","2016-09-13 07:06:28",8
"Hyperledger Fabric","Build Docker image for Kafka/Zookeeper",,Task,Medium,Closed,"2016-09-13 07:05:14","2016-09-13 07:05:14",2
"Hyperledger Fabric","Bootstrapping a blockchain network with Orderers and Peers","Bootstrapping Fabric network including bootstrapping 2 components: Orderers and Peers. Orderers make up a network of nodes with mesh connections. Peers network uses gossip to communicate with one another but direct connection with the Orderer network. All connections are TLS.    Each Orderer is configured by an administrative CLI command, which provides the necessary bootstrapping data, including a list of trusted roots, a list of Orderer certificates and IP addresses, a set of specific consensus algorithm properties, and access control policies. With this information, an Orderer may start up and connect with other Orderers.    Each Peer requires at least the following configurations:  # An enrollment certificate to participate in the network. The certificate may come from any CA as long as the CA is part of the trusted roots on the consensus service that the Peer will connect to  # A list of the Orderer certificates and IP addresses, which the administrative CLI from the consensus service can generate  # A list of trusted root certificates  # An optional list of channels that the Peer should subscribe. Unless explicitly configured, the Peer does not subscribe to any channels upon starting up    ",Epic,Medium,Closed,"2016-09-12 20:14:48","2016-09-12 20:14:48",8
"Hyperledger Fabric","As an infrastructure developer i want to ensure that all crypto calls within the nodejs client go through the fabric crypto library (BCCSP)","This requires that this library defined in FAB-354, and whose software provider was implemented in FAB-355/FAB-823, is used throughout the fabric client sdk in Node.  ",Task,Medium,Closed,"2016-09-12 15:31:11","2016-09-12 15:31:11",8
"Hyperledger Fabric","As an infrastructure developer and application developer i want to have availale a software based crypto provider implementing the interface of FAB-354 in golang.","Implement a software provider implementing the interface described in FAB-354 in Golang to be used by the peer core code.",Story,High,Closed,"2016-09-12 15:29:46","2016-09-12 15:29:46",8
"Hyperledger Fabric","Pluggable interface for crypto algorithms to accommodate alternative implementations","As an infrastructure developer I want to be able to substitute crypto library    This requires the following tasks take place:    1. Define a modular crypto library interface that would satisfy the crypto needs of membership services, peer and client code,    2. Re-factor the code implementing crypto functionalities in HPL/fabric within a software crypto provider that implements the interface specified in (1)    3. Update the HPL/fabric crypto calls to use the specified API and use the library provided by (1) and (2).  ",Epic,High,Closed,"2016-09-12 15:24:17","2016-09-12 15:24:17",24
"Hyperledger Fabric","Review fabric-next protocol from a security perspective","This is a task to review the messages exchanged within fabric-next architecture, and figure out places where tcert-based authentication is to be put in place.     This is a long-term task that needs to be done prior and during the transition of the security code to the new architecture. ",Task,Medium,Closed,"2016-09-12 14:48:18","2016-09-12 14:48:18",12
"Hyperledger Fabric","Control rockdb logging","Fabric peer uses default configurations for logging RocksDB - which produces massive logs in the LOG files. For better managing RockDB logs, RocksDB allows setting following logs related properties  - 1) max_log_file_size, 2) keep_log_file_num, and 3) info_log_level    Though a newer version (4.3) of RocksDB allows loading properties from an `ini` file (https://github.com/facebook/rocksdb/wiki/RocksDB-Options-File) - gorockdb package is yet to catch up for exposing this option into golang.    Current possibility is to expose these configs into core.yaml and programmatically set these on RocksDB options while opening the DB. ",Task,Low,Closed,"2016-09-12 11:33:23","2016-09-12 11:33:23",1
"Hyperledger Fabric","Update nodejs client to support a transaction structure where metadata is encrypted independently to the payload","New transaction structure that enables metadata to be independently encrypted to the transaction payload needs to be supported by the nodejs client. So far this is only supported by the golang client.",Sub-task,Medium,Closed,"2016-09-12 11:02:43","2016-09-12 11:02:43",4
"Hyperledger Fabric","Create Rawledger API","Create a Rawledger API which can be used by any orderer.    This should also cover moving the ramledger implementation of Solo out into its own package, and converting solo to depend on the new abstraction.",Task,Medium,Closed,"2016-09-08 21:09:24","2016-09-08 21:09:24",2
"Hyperledger Fabric","[node-SDK] Technical debt","This will help with creating a cleaner workspace for node.js developers working on the node.js SDK, and eliminate sub-optimal parts that are prone to breaks:  - build scripts that does -g installs  - reliance on vagrant  - make based build scripts are not best suited for node.js development",Story,Highest,Closed,"2016-09-07 19:59:37","2016-09-07 19:59:37",8
"Hyperledger Fabric","enablement for ppc64le","https://gerrit.hyperledger.org/r/#/c/835/ should be ported to v0.6. This is one of the last features we agreed to add to v0.6.",Task,Highest,Closed,"2016-09-06 21:49:13","2016-09-06 21:49:13",2
"Hyperledger Fabric","TestHTTPExecuteDeployTransaction failing on master","https://gerrit.hyperledger.org/r/#/c/811/  introduced a breaking change for unit tests on master.    TestHTTPExecuteDeployTransaction is failing on the master branch because it passing http://github.com/hyperledger/fabric-test-resources/examples/chaincode/go/chaincode_example01 in as a parameter.  This would be ok since it is trying to test getting remote chaincode, but the issue is that the chaincode in that repo is implementing new interface(s) / method(s) based on the convergence branch.          ",Task,Medium,Closed,"2016-09-03 19:37:15","2016-09-03 19:37:15",1
"Hyperledger Fabric","Solve the can't find hyperledger/fabric-baseimage:latest issue when not in vagrant","This issue comes up in two circumstances (maybe more):  - if you want to make fabric or make images outside of vagrant  - if you try to use a docker-based setup (for peers and membersrvc), all seems fine until you try to deploy a chaincode, where the peer running inside docker is trying to set up another docker instance for the chaincode    in both cases you encounter the error that the image hyperledger/fabric-baseimage:latest is not available. One had to work around it by pulling the :x86_64-0.0.x tag and re-tag is to latest. but that's no obvious at all.    can this experience be improved?  ",Task,Highest,Closed,"2016-09-01 20:25:16","2016-09-01 20:25:16",1
"Hyperledger Fabric","upgrade golang from 1.6 to 1.7","Golang 1.7 released with enhanced performance and bug fixes.    We should support it ASAP.",Task,Medium,Closed,"2016-09-01 03:24:06","2016-09-01 03:24:06",4
"Hyperledger Fabric","separate out base image creation and publishing","@<USER>and I were just discussing (lamenting) the state of the build and some of the patches that are looking to simplify and shorten the build. We started talking about https://gerrit.hyperledger.org/r/#/c/721/ which was attempting to eliminate unnecessary builds of the base image every time we build. We had previously discussed pulling out the build for the various base images into a separate repository and then controlling the specific version by referencing a specific tag in the fabric (and other) builds where we are explicitly calling out a bump of a version tag to push, and we are pulling a previously explicitly tagged version from atlas or dockerhub.    I like this approach as it is cleaner, and we can simplify and reduce the time to build. I would propose we pull out images/base into its own repository with the same set of maintainers and we adapt its build pipeline to include an explicit change required to push a version that is governed under 2+2 merge policy,",Task,Medium,Closed,"2016-08-31 15:38:17","2016-08-31 15:38:17",4
"Hyperledger Fabric","Enable power node in Jenkins CI","@bsmitha requested us to setup Power node in Jenkins CI.",Task,Medium,Closed,"2016-08-31 01:36:29","2016-08-31 01:36:29",2
"Hyperledger Fabric","Please move chaintool to a more reliable host or have keepalive flag on","I have been failing to do fresh vagrant up for a week, and I finally figured out what happened.  During certain stage of fresh vagrant up, the following command is issued:  curl -L https://github.com/hyperledger/fabric-chaintool/releases/download/v0.8.1/chaintool > build/bin/chaintool  , and it always fails with the message of curl: (56) SSL read: error:00000000:lib(0):func(0):reason(0), errno 104    So I run the same command in another console and find out the connectivity is quite poor.  Maximum download speed is around 3K and drops to 0 from time to time, then eventually timeout.  I can wait if it's just slow, but this makes it impossible to successfully finish vagrant up   !image-2016-08-31-06-37-40-302.png|thumbnail! ",Task,High,Closed,"2016-08-31 00:15:24","2016-08-31 00:15:24",1
"Hyperledger Fabric","restore Jenkins pipeline for Z","restore Jenkins pipeline for Z  migrate https://github.com/hyperledger-archives/fabric/pull/2228 to Gerrit",Task,High,Closed,"2016-08-30 18:59:39","2016-08-30 18:59:39",1
"Hyperledger Fabric","node.js SDK - add API to send endorsed deployment transaction to orderer","This initial phase is to send to an orderer based on SOLO. The API should take a proper parameter assembled from the returned data of the sendDeploymentProposal() call, and send to the orderer for consensus, which will then deliver to committers for validating and committing to ledger.    Note that the event notification on transaction complete, error will be tracked separately.",Sub-task,High,Closed,"2016-08-26 20:00:01","2016-08-26 20:00:01",8
"Hyperledger Fabric","node.js SDK - add API to send endorsed transaction to Orderer","the transaction payload includes the proposal-responses containing the endorsements.    the backend for this processing is asynchronous, it's not complete until the transaction is successfully validated and committed to the ledger, which is notified via an event.    Due to the async nature of the server process, the API should return a context object that can then track the event on the transaction (complete, error, or custom events defined by the chaincode).  ",Sub-task,Medium,Closed,"2016-08-26 19:31:03","2016-08-26 19:31:03",4
"Hyperledger Fabric","node.js SDK - add API to send chaincode deploy endorsement proposals","Similar to FAB-251 but targeting a specific system chaincode for deploy: the Lifecycle System Chaincode. Endorsers will have a special API for chaincode deployment proposal (as opposed to normal transaction proposals).",Sub-task,High,Closed,"2016-08-26 18:22:22","2016-08-26 18:22:22",4
"Hyperledger Fabric","add commit sha to version for jenkins builds and -local to local builds","See https://gerrit.hyperledger.org/r/#/c/571/ as first step in adding versioning to binary. We should look to discriminating between a formal CI/Jenkins build (which we can add commit sha to version) published to dockerhub etc from a local build that might have uncommitted changes.",Task,Medium,Closed,"2016-08-25 13:38:17","2016-08-25 13:38:17",1
"Hyperledger Fabric","Expose ledger rich query API to chaincode: As a chaincode consumer, I need to query the ledger using a rich data language (similar capability to SQL, but not necessarily SQL syntax), so that I have flexibility beyond simple key/value lookups",,Story,Medium,Closed,"2016-08-20 12:39:26","2016-08-20 12:39:26",8
"Hyperledger Fabric","Ledger simple provenance: I want to see the full history of key values across time","Querying for full history of keys will require a new history database. See attached slides for details.",Story,Medium,Closed,"2016-08-20 12:27:10","2016-08-20 12:27:10",8
"Hyperledger Fabric","Ledger Blockchain query API: I need to query the ledger outside of chaincode","Create query system chaincode layer to execute queries against ledger.",Story,Medium,Closed,"2016-08-20 12:13:48","2016-08-20 12:13:48",4
"Hyperledger Fabric","Ledger APIs to query Blocks/Transactions, including rich query and history of key values","- Ledger APIs have been implemented and need to be exposed to SDK:    -- GetBlockchainInfo    -- GetBlocksByNumber    -- GetBlockByNumber    -- GetBlockByHash    -- GetTransactionById    -- ExecuteQuery    ",Story,Highest,Closed,"2016-08-20 12:11:34","2016-08-20 12:11:34",8
"Hyperledger Fabric","Ledger commit validation: As a consumer of the ledger APIs (Ordering service gRPC), I need the commit of a batch of transactions to perform MVCC validation on the batch prior to committing, so that invalid transactions get removed (Commit Part 2)","Implement RemoveInvalidTransactions()    - Implement MVCC check",Story,Highest,Closed,"2016-08-20 12:04:01","2016-08-20 12:04:01",4
"Hyperledger Fabric","Ledger basic commit: As a consumer of the ledger APIs (Ordering service gRPC), I need to commit a batch of transactions to the file based ledger datastore (Commit Part 1- ignoring validation initially)",,Story,Highest,Closed,"2016-08-20 11:58:26","2016-08-20 11:58:26",8
"Hyperledger Fabric","Ledger advanced simulation: As a consumer of the ledger APIs (Endorser peer chaincode), I need the ability to manipulate keys in various ways, so that I have flexibility in chaincode to get and set the state I need","- Implement QueryExecutor.GetStateRangeScanIterator()    - Implement QueryExecutor.GetStateMultipleKeys()    - Implement TxSimulator.DeleteState()    - Implement TxSimulator.SetStateMultipleKeys()",Story,Highest,Closed,"2016-08-20 11:56:13","2016-08-20 11:56:13",2
"Hyperledger Fabric","Ledger basic simulation: As a consumer of the ledger APIs (Endorser peer), I need to simulate a transaction proposal against the ledger, so that I can build a read/write data set for the ultimate ledger transaction",,Story,Highest,Closed,"2016-08-19 20:36:24","2016-08-19 20:36:24",8
"Hyperledger Fabric","publish ccenv and src docker images along with peer and membersrvc images","publish ccenv and src docker images along with peer and membersrvc images after merge in gerrit.     In the current approach, we are publishing peer and membersrvc images from Jenkins after every successful merge. [~<USER> suggested, we have to publish other images (ccenv and src) images to docker hub along with peer and membersrvc so that we no need to depend on baseimage.    ex: hyperledger/fabric-ccenv:v1.0.0 hyperledger/fabric-src:v1.0.0 hyperledger/fabric-peer:v1.0.0 hyperledger/fabric-membersrvc:v1.0.0  ",Task,Medium,Closed,"2016-08-17 22:03:34","2016-08-17 22:03:34",1
"Hyperledger Fabric","BFT Orderers need to sign batches","BFT orderers have to provide signatures so that validator peers can use the set of signatures to accept validity of a batch without having to connect to f+1 orderers.    All orderers already sign with their own key.",Story,Medium,Closed,"2016-08-17 15:45:27","2016-08-17 15:45:27",2
"Hyperledger Fabric","Ubuntu 16.04 Support","Moved over from https://github.com/hyperledger/fabric/issues/1305      {quote}We are currently based on 14.04 LTS. The new LTS 16.04 was released recently and we should evaluate whether rebasing the various platforms (vagrant, docker, etc) make sense. One benefit that comes to mind is a few packages that we have to build by hand (go1.6) might become available via official Ubuntu supported avenues.    One particular snafu is I am unsure if 16.04 is available in TravisCI. I suspect its only a matter of time if it is not supported already, but this would be largely out of our control. I cannot predict what might happen if we target 16.04 but certain environments are held back on older releases.{quote}",Task,Medium,Closed,"2016-08-16 22:53:49","2016-08-16 22:53:49",4
"Hyperledger Fabric","I want to run the COP server in a cluster","Run the COP server in a cluster sharing the same DB.  Will test with HAProxy fronting the cluster, though any load balancer should do.  No session affinity should be required.",Story,Highest,Closed,"2016-08-16 19:23:34","2016-08-16 19:23:34",8
"Hyperledger Fabric","Ledger client query: I need to query the ledger outside of chaincode (Ledger API layer)","Implement {{ExecuteQuery(query string) (ResultsIterator, error)}} in the {{QueryExecutor}} interface    Implemented in FAB-1395.",Story,Medium,Closed,"2016-08-12 22:10:31","2016-08-12 22:10:31",4
"Hyperledger Fabric","Implement RawLedger interface","Implement the raw ledger for storing transactions received in batches from the ordering service.    Implementation of {{type RawLedger interface}} in the ledger API.",Task,Medium,Closed,"2016-08-12 20:21:00","2016-08-12 20:21:00",4
"Hyperledger Fabric","Prototype ordering service based on Kafka","As a network deployer, I want an ordering service based on Kafka so that I have a point of reference for block throughput and latency. Build an ordering service on top of Kafka, following the diagram below and this proto definition file for the interface: https://github.com/<USER>kafka-orderer/blob/devel/ab/ab.proto",Epic,Medium,Closed,"2016-08-11 19:43:13","2016-08-11 19:43:13",24
"Hyperledger Fabric","Endorser simulation of transactions.","Story: Developer needs the ability to gain signatures from endorsers as defined by a policy by simulating a transaction without writing to the ledger create, so that they can submit a transaction.    Endorsers simulate tx with state and reply with rw set of all keys that were modified.    A submitter composes a transaction consisting of [header, payload, rw-set] where rw-set is the set containing the state variables that the transaction reads from (read-set) and the state variables that the transaction writes to (write-set). The rw-set is created via transaction execution simulation (not writing to database). This simulation is also done by the endorsers of the transaction to fulfill the endorsement policy of the transaction.",Story,Medium,Closed,"2016-08-11 19:32:40","2016-08-11 19:32:40",2
